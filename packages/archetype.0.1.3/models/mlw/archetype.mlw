theory Types

  use int.Int
  use mach.int.UInt32

  (* default type mapping *)
  type key     = int
  type role    = int
  type address = int
  type uint    = uint32
  type tez     = int
  type date    = int
  type string  = int

  constant max_uint : int = UInt32.max_uint32

  exception Break
  exception NotFound
  exception KeyExist
  exception InvalidCaller
  exception InvalidCondition

end

theory Contract

  use Types
  use int.Int
  use mach.int.UInt32
  use list.List
  use list.Append
  use array.Array

  type storage = abstract mutable {}
  val function get_balance storage : tez
  val function get_transferred storage : tez
  val function set_balance storage tez : unit

  (* currency transfer during transaction *)
  type transfer = {
     destination_ : address;
     amount_      : tez;
  }

  type transfers = list transfer

  let no_transfer : transfers = Nil

  let update_balance (s : storage)
    requires { get_transferred s + get_balance s <= max_uint }
    ensures  { get_balance s = old (get_balance s) + (get_transferred s)}
  =
    let part_sum = get_balance s + get_transferred s in
    set_balance s part_sum

  let exec_transfer (s : storage) (a : address) (c : tez) (ops : transfers) : transfers
    requires { c <= get_balance s }
    ensures  { old (get_balance s) = (get_balance s) + c }
  =
    set_balance s (get_balance s - c);
    let transfer = { destination_ = a; amount_ = c } in
    ops ++ (Cons transfer Nil)

end

(* non ghost map *)
module Map

  (* import non ghost equality on integer *)
  use int.Int
  use list.List
  use Types

  type map 'value = key -> 'value

  let function get (f: map 'value) (x: key) : 'value = f x

  let function set (f: map 'value) (x: key) (v: 'value) : map 'value 
  ensures { result x = v }
  ensures { forall k : key. k <> x -> result k = f k }
  = fun (y : key) -> if y = x then v else f y

  let function const (v : 'value) : map 'value = fun _ -> v

  let rec mapl (f: 'a -> 'b) (l: list 'a) : list 'b =
  variant { l }
    match l with
    | Nil      -> Nil
    | Cons x r -> Cons (f x) (mapl f r)
    end

end

theory AssetCollection

  use list.List
  use list.Length
  use list.Nth
  use int.Int
  use option.Option

  use Types
  
  clone list.Sorted      as S with type t       = int, 
                                   predicate le = (<=)

  val function witness : 'a

  let function gen_nth (i : int) (c : list 'a) : 'a
  = 
  match nth i c with
  | Some v -> v
  | None -> witness
  end

  predicate unique (l : list int) = 
  forall i j : int.
    0 <= i < length l ->
    0 <= j < length l ->
    i <> j ->
    nth i l <> nth j l
  
  let rec predicate lmem (i : int) (l : list int) : bool 
  variant { l }
  = match l with
    | Cons e tl ->
      if e = i
      then true
      else lmem i tl
    | Nil -> false
    end

  type acol = {
    content : list int;
  } invariant {  
    S.sorted content
  } invariant {
    unique content
  } by {
    content = Nil
  }

  let mkacol l = { content = l; }

  let function mem (k : key) (c : acol) = lmem k c.content

  let function card (c : acol) = length c.content

  predicate (==) (c1 c2 : acol) = forall k : key. mem k c1 <-> mem k c2

  lemma extensionality : forall c1 c2 : acol. 
  c1 == c2 -> c1 = c2

  predicate subset (c1 c2 : acol)
  = forall k : key. mem k c1 -> mem k c2

  let function empty = { content = Nil; }

  let function singleton (k : key) : acol = { content = Cons k Nil; }

  lemma mem_singleton: forall k1 k2 : key. mem k1 (singleton k2) -> k1 = k2

  predicate is_empty (c : acol) = forall m : key. not (mem m c)

  lemma mem_empty : is_empty empty

  function diff (c1 c2 : acol) : acol
  axiom diff_def: forall c1 c2 : acol, x : key. mem x (diff c1 c2) <-> mem x c1 /\ not (mem x c2)
  
  function inter (c1 c2 : acol) : acol
  axiom inter_def : forall c1 c2 : acol, x : key. mem x (inter c1 c2) <-> mem x c1 /\ mem x c2 

  function union (c1 c2 : acol) : acol
  axiom union_def : forall c1 c2 : acol, x : key. mem x (union c1 c2) <-> mem x c1 \/ mem x c2

  (*axiom zero_card: 
  forall c : acol. is_empty c -> card c = 0*)

  let function nth (i : int) (c : acol) : key
  ensures { 0 <= i < card c -> result <> witness }
  ensures { 0 <= i < card c -> mem result c }
  = gen_nth i c.content

  (* this axiom ensures that all asset keys are unique, 
     which is translated to the injectivity of nth *)
  (*axiom inj_nth : forall i j : int, c : acol.
    0 <= i < card c ->
    0 <= j < card c ->
    i = j <-> nth i c = nth j c*)

  (*axiom subset_nth : forall c1 c2 : acol.
    subset c1 c2 <-> forall k : int. 0 <= k < card c1 -> mem (nth k c1) c2*)
  
  lemma subset_diff: forall c1 c2 : acol. subset (diff c1 c2) c1

  lemma subset_inter1: forall c1 c2 : acol. subset (inter c1 c2) c1

  lemma subset_inter2: forall c1 c2 : acol. subset (inter c1 c2) c2

  lemma subset_union1: forall c1 c2 : acol. subset c1 (union c1 c2)

  lemma subset_union2: forall c1 c2 : acol. subset c2 (union c1 c2) 

  (*lemma split_mem : forall l : list 'a, x y : 'a.
   Mem.mem x l \/ x = y <-> Mem.mem x (l ++ (Cons y Nil))*)   

  lemma card_union: forall c1 c2 : acol.
  card (union c1 c2) = card c1 + card c2 - card (inter c1 c2)

  lemma card_diff2: forall c1 c2 : acol.
  subset c2 c1 ->
  card (diff c1 c2) = card c1 - card c2 

  function head (i : int) (c : acol) : acol
  axiom head_def: forall c : acol, i j : int. 0 <= i < j -> nth j (head i c) = nth j c
  axiom head_card: forall c : acol, i : int. 0 <= i < card c -> card (head i c) = i 
  axiom head_all: forall c : acol, i : int.  i >= card c ->  head i c = c

  (* for loop invariant *)
  axiom head_add: forall c : acol, i : int. 0 <= i < card c -> 
  head (i+1) c = union (singleton (nth i c)) (head i c)

  function tail (i : int) (c : acol) : acol
  axiom tail_def: forall c : acol, i j : int. i <= j < card c -> nth (j - i) (tail i c) = nth j c
  axiom tail_card: forall c : acol, i : int. 0 <= i < card c -> card (tail i c) = card c - i 
  axiom tail_empty: forall c : acol, i : int.  i >= card c ->  tail i c = empty
  axiom tail_all: forall c : acol. tail 0 c = c

  axiom tail_add: forall c : acol, i : int. 0 <= i < card c ->
  tail (i+1) c = diff (tail i c) (singleton (nth i c))

  axiom mem_tail: forall c : acol, i : int. 0 <= i < card c ->
  mem (nth i c) (tail i c)

  (* API ----------------------------------------------------------------------*)

  let rec insert (i : int) (l : list int) : list int
  variant { l }
  requires { S.sorted l }
  ensures { S.sorted result }
  = match l with
    | Nil -> Cons i Nil
    | Cons e tl -> 
      if i < e then Cons i (Cons e tl) 
      else Cons e (insert i tl)
    end

  let rec sort (l : list int) : list int
  variant { l }
  ensures { S.sorted result }
  = match l with
    | Nil -> Nil
    | Cons e tl -> insert e (sort tl)
    end

  let add (a : key) (c : acol) : acol
  raises { KeyExist }
  reads { c }
  ensures { not (mem a c) }
  ensures { mem a result }
  ensures { result = union c (singleton a) }
  = if mem a c then raise KeyExist;
    mkacol (sort (Cons a c.content))

  let remove (a : key) (c : acol) : acol
  raises { NotFound }
  reads { c }
  ensures { mem a c }
  ensures { not (mem a result) }
  ensures { result = diff c (singleton a) }
  = if not (mem a c) then raise NotFound;
    let rec rec_rm l =
    variant { l }
    match l with
    | Nil -> Nil
    | Cons e tl ->
      if e = a 
      then rec_rm tl
      else Cons e (rec_rm tl) 
    end in
    mkacol (rec_rm c.content)

end

(*module Tomap

  use AssetCollection
  use Map
  use Types
  use list.List
  use list.Length
  use int.Int

  let rec to_map (c : acol) (l : list 'value) (m : map 'value) : map 'value 
   variant { c.content, l }
   requires { card c = length l }
   ensures { forall k : key. mem k c -> (exists i : int. 0 <= i < card c /\ gen_nth i l = get result k) } 
   =
   match (c.content,l) with
   | Nil,Nil -> m
   | Cons k tlacol, Cons a tlasset -> to_map (mkacol tlacol) tlasset (set m k a) 
   end


end*)

(*theory Filter
  use int.Int
  use list.List

  use Types
  use Contract
  use AssetCollection
  
  type storage = abstract mutable {}
  
  val function test env storage key : bool

  let rec function filter (e : env) (s : storage) (c : acol) : acol
  variant { c.content }
  ensures { forall a : key. mem a result -> test e s a }
  ensures { subset result c }
  =
  match c.content with
  | Nil -> Nil
  | Cons a tl ->
    if test e s a
    then Cons a (filter e s tl)
    else filter e s tl
  end

end*)

theory Sum

  (* import comparison operators on key *)
  use int.Int
  use list.List
  use Types
  use AssetCollection

  type storage = abstract mutable {}

  (* should it be generalized to any summable type  ? *)
  val function f storage key : int

  let function part_sum (s : storage) (c : acol) (i j : int) : int = 
    let rec rec_sum (k : int) (l : acol) 
    variant { l.content }
    = match l.content with
      | Cons e tl ->
        if i <= k < j 
        then f s e + rec_sum (k+1) (mkacol tl) 
        else rec_sum (k+1) (mkacol tl)
      | Nil -> 0
      end in
    rec_sum 0 c

  let function sum (s : storage) (c : acol) = part_sum s c 0 (card c)

  lemma part_sum_def_empty :
    forall s : storage, c: acol, i j : int.
    j <= i -> part_sum s c i j = 0

  lemma part_sum_def_non_empty :
    forall s : storage, c: acol, i j : int.
    i < j -> part_sum s c i j = f s (nth i c) + part_sum s c (i+1) j

  lemma part_sum_right_extension:
    forall s : storage, c : acol, i j : int.
    i < j -> part_sum s c i j = part_sum s c i (j-1) + f s (nth (j-1) c)

  lemma part_sum_transitivity :
    forall s : storage, c : acol, i k j : int. i <= k <= j ->
    part_sum s c i j = part_sum s c i k + part_sum s c k j

  lemma part_sum_eq :
    forall s : storage, c1 c2 : acol, i j : int.
    (forall k : int. i <= k < j -> mem k c1 /\ mem k c2) -> 
    part_sum s c1 i j = part_sum s c2 i j
      
  lemma part_sum_extension:
    forall s1 s2: storage, c : acol, i j m : int.
    (forall k : int. i <= k <= j -> nth k c <> m -> f s1 (nth k c) = f s2 (nth k c)) ->
    part_sum s1 c i j - f s1 m = part_sum s2 c i j - f s2 m

  (* part_sum is functional towards (f s) *)
  lemma sum_fun_storage:
    forall s1 s2 : storage, c : acol.
    (forall x : key. mem x c -> f s1 x = f s2 x) -> (* f s1 = f s2 *)
    sum s1 c = sum s2 c (* part_sum c i j (f s1) = part_sum c i j (f s2) *) 

  lemma sum_fun_storage2:
    forall s1 s2 : storage, field : storage -> acol.
    (forall x : key. mem x (field s1) -> f s1 x = f s2 x) ->
    sum s2 (field s1) = sum s1 (field s1) 

  lemma sum_empty:
    forall s : storage, c : acol.
    is_empty c -> sum s c = 0

  lemma sum_union:
    forall s : storage, c1 c2 : acol.
    sum s (union c1 c2) = sum s c1 + sum s c2 - sum s (inter c1 c2)

  (*lemma sum_diff:
    forall s : storage, c1 c2 : acol.
    sum s (diff c1 c2) = sum s c1 - sum s (inter c1 c2)*)

  lemma sum_diff2:
    forall s : storage, c1 c2 : acol.
    subset c2 c1 ->
    sum s (diff c1 c2) = sum s c1 - sum s c2  

end

theory Trace
  
  use list.List
  use list.Mem
  use option.Option

  use Types
  use Contract

  type asset
  type entry
  type field

  type action =
  | Add asset
  | Rm asset
  | Any asset
  | Get asset
  | Update field
  | Iterate asset

  type trace =  {
    entry : option entry;
    action : action;
  }
  
  type log = list trace

  let function mk_trace (e : option entry) (c : action) : log = Cons ({
    entry = e;
    action = c;
  }) Nil

  predicate sub (a b : list 'v) = 
  forall e : 'v. mem e a -> mem e b

end

module Lib
 
  use export int.Int
  use export ref.Ref
  use export option.Option
  use export list.List
  use export list.Length
  use export list.Append
  
  use export Types
  use export Contract
  use export Map
  use export AssetCollection
  use export Trace

end
