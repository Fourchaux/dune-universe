module Escrow

  use int.Int

  use archetype.Types
  use archetype.Contract

  type states = Created | Aborted | Confirmed | Canceled | Transferred

  (* contract storage *)
  type storage = {
     mutable buyer    : role;
     mutable debitor  : role;
     mutable seller   : role;
     mutable creditor : role;
     mutable oracle   : role;
     mutable price    : tez;
     mutable penalty  : tez;
     mutable deadline : date;
     mutable state    : states;
  }

  (* transition from Created to Aborted *)
  let abort (e : env) (s : storage) : transfers
    (* archetype 'transition' property '*)
    requires { s.state = Created }
    (* archetype 'called by' property '*)
    requires {
         caller e = s.buyer
      \/ caller e = s.seller
    }
    (* archetype global assert *)
    requires { s.state = Transferred -> balance e = 0 }
    ensures  { s.state = Transferred -> balance e = 0 }
    = s.state <- Aborted;
      empty

  (* transfer price *)
  let transfer_price (e : env) (s : storage) : transfers
    (* archetype 'transition' property '*)
    requires { s.state = Created }
    (* archetype 'called by' property '*)
    requires { caller e = s.buyer }
    (* archetype 'transferred' property *)
    requires { transferred e = s.price }
    (* generic uint constraints *)
    requires { balance e + transferred e <= max_uint }
    (* archetype global assert *)
    requires { s.state = Transferred -> balance e = 0 }
    ensures  { s.state = Transferred -> balance e = 0 }
    ensures  { balance e = old (balance e) + s.price }
    ensures  { s.state = old s.state }
    = update_balance e;
      empty

  (* transfer penalty *)
  let transfer_penalty (e : env) (s : storage) : transfers
    (* archetype 'transition' property '*)
    requires { s.state = Created }
    (* archetype 'called by' property '*)
    requires { caller e = s.seller }
    (* archetype 'transferred' property *)
    requires { transferred e = s.penalty }
    (* generic uint constraints *)
    requires { balance e + transferred e <= max_uint }
    (* archetype global assert *)
    requires { s.state = Transferred -> balance e = 0 }
    ensures  { s.state = Transferred -> balance e = 0 }
    ensures { balance e = old (balance e) + s.penalty }
    = update_balance e;
      empty

  (* transition from Created to Confirm *)
  let confirm (e : env) (s : storage) : transfers
    (* archetype 'transition' property '*)
    requires { s.state = Created }
    (* archetype 'condition' property '*)
    requires { balance e = s.price + s.penalty }
    (* archetype global assert *)
    requires { s.state = Transferred -> balance e = 0 }
    ensures  { s.state = Transferred -> balance e = 0 }
    = s.state <- Confirmed;
      empty

  (* transition from Confirmed to Transferred *)
  let transfer (e : env) (s : storage) : transfers
    requires { s.state = Confirmed }
    requires { caller e = s.oracle }
    requires { now e <= s.deadline }
    (* !! Propagated precondition from 'confirm' transaction *)
    requires { balance e = s.price + s.penalty }
    (* archetype global assert *)
    requires { s.state = Transferred -> balance e = 0 }
    ensures  { s.state = Transferred -> balance e = 0 }
  =  s.state <- Transferred;
     let tr = exec_transfer e s.seller s.price empty in
     exec_transfer e s.buyer s.penalty tr

end