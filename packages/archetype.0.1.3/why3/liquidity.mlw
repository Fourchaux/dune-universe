theory Int

  use export int.Int

  val int_eq int int : bool
  val int_ne int int : bool
  val int_ge int int : bool
  val int_le int int : bool
  val int_gt int int : bool
  val int_lt int int : bool

  val toint int : int

end

theory Nat

  use int.Int

  type nat

  val nat_eq nat nat : bool
  val nat_ne nat nat : bool

  val nat_ge nat nat : bool
  val nat_le nat nat : bool
  val nat_gt nat nat : bool
  val nat_lt nat nat : bool

  val nat_plus  nat nat : nat
  val nat_sub (nat, nat) : nat

  val nat_zero () : nat
  val nat_one  () : nat

  val tonat Int.int : nat

end

theory Address

  type address
  type key_hash

  val key_to_addr key_hash : address

  val toaddress key_hash : key_hash
  val mkaddress unit : key_hash

  val add_eq address address : bool
  val add_ne address address : bool

  val kh_eq key_hash key_hash : bool
  val kh_ne key_hash key_hash : bool

  val default_address : key_hash

end

theory Timestamp

  type timestamp

  val mktimestamp unit : timestamp

  val tim_eq timestamp timestamp : bool
  val tim_ne timestamp timestamp : bool

  val tim_ge timestamp timestamp : bool
  val tim_le timestamp timestamp : bool
  val tim_gt timestamp timestamp : bool
  val tim_lt timestamp timestamp : bool

end

theory Tez

  use int.Int

  type tez

  val totez int : tez

  val tez_eq  tez tez : bool
  val tez_ne  tez tez : bool

  val tez_gt  tez tez : bool
  val tez_ge  tez tez : bool
  val tez_lt  tez tez : bool
  val tez_le  tez tez : bool

  val tez_plus   tez tez : tez
  val tez_minus  tez tez : tez

end

theory String

  type string

  val str_eq string string : bool

end

theory Utils

  use int.Int
  use list.List

  val sort ((('a , 'a) -> int) , list 'a) : list 'a

  (* tuple *)
  let get_0_1 (v : ('a)) : 'a = let (a) = v in a

  let get_0_2 (v : ('a , 'b)) : 'a = let (a,_) = v in a
  let get_1_2 (v : ('a , 'b)) : 'b = let (_,b) = v in b

  let get_0_3 (v : ('a , 'b , 'c)) : 'a = let (a,_,_) = v in a
  let get_1_3 (v : ('a , 'b , 'c)) : 'b = let (_,b,_) = v in b
  let get_2_3 (v : ('a , 'b , 'c)) : 'c = let (_,_,c) = v in c

  let get_0_4 (v : ('a , 'b , 'c , 'd)) : 'a = let (a,_,_,_) = v in a
  let get_1_4 (v : ('a , 'b , 'c , 'd)) : 'b = let (_,b,_,_) = v in b
  let get_2_4 (v : ('a , 'b , 'c , 'd)) : 'c = let (_,_,c,_) = v in c
  let get_3_4 (v : ('a , 'b , 'c , 'd)) : 'd = let (_,_,_,d) = v in d

  let get_0_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'a = let (a,_,_,_,_) = v in a
  let get_1_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'b = let (_,b,_,_,_) = v in b
  let get_2_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'c = let (_,_,c,_,_) = v in c
  let get_3_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'd = let (_,_,_,d,_) = v in d
  let get_4_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'e = let (_,_,_,_,e) = v in e

  let get_0_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'a = let (a,_,_,_,_,_) = v in a
  let get_1_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'b = let (_,b,_,_,_,_) = v in b
  let get_2_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'c = let (_,_,c,_,_,_) = v in c
  let get_3_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'd = let (_,_,_,d,_,_) = v in d
  let get_4_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'e = let (_,_,_,_,e,_) = v in e
  let get_5_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'f = let (_,_,_,_,_,f) = v in f

  let get_0_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'a = let (a,_,_,_,_,_,_) = v in a
  let get_1_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'b = let (_,b,_,_,_,_,_) = v in b
  let get_2_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'c = let (_,_,c,_,_,_,_) = v in c
  let get_3_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'd = let (_,_,_,d,_,_,_) = v in d
  let get_4_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'e = let (_,_,_,_,e,_,_) = v in e
  let get_5_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'f = let (_,_,_,_,_,f,_) = v in f
  let get_6_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'g = let (_,_,_,_,_,_,g) = v in g

  let get_0_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'a = let (a,_,_,_,_,_,_,_) = v in a
  let get_1_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'b = let (_,b,_,_,_,_,_,_) = v in b
  let get_2_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'c = let (_,_,c,_,_,_,_,_) = v in c
  let get_3_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'd = let (_,_,_,d,_,_,_,_) = v in d
  let get_4_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'e = let (_,_,_,_,e,_,_,_) = v in e
  let get_5_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'f = let (_,_,_,_,_,f,_,_) = v in f
  let get_6_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'g = let (_,_,_,_,_,_,g,_) = v in g
  let get_7_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'h = let (_,_,_,_,_,_,_,h) = v in h

  let get_0_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'a = let (a,_,_,_,_,_,_,_,_) = v in a
  let get_1_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'b = let (_,b,_,_,_,_,_,_,_) = v in b
  let get_2_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'c = let (_,_,c,_,_,_,_,_,_) = v in c
  let get_3_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'd = let (_,_,_,d,_,_,_,_,_) = v in d
  let get_4_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'e = let (_,_,_,_,e,_,_,_,_) = v in e
  let get_5_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'f = let (_,_,_,_,_,f,_,_,_) = v in f
  let get_6_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'g = let (_,_,_,_,_,_,g,_,_) = v in g
  let get_7_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'h = let (_,_,_,_,_,_,_,h,_) = v in h
  let get_8_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'i = let (_,_,_,_,_,_,_,_,i) = v in i

  let get_0_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'a = let (a,_,_,_,_,_,_,_,_,_) = v in a
  let get_1_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'b = let (_,b,_,_,_,_,_,_,_,_) = v in b
  let get_2_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'c = let (_,_,c,_,_,_,_,_,_,_) = v in c
  let get_3_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'd = let (_,_,_,d,_,_,_,_,_,_) = v in d
  let get_4_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'e = let (_,_,_,_,e,_,_,_,_,_) = v in e
  let get_5_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'f = let (_,_,_,_,_,f,_,_,_,_) = v in f
  let get_6_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'g = let (_,_,_,_,_,_,g,_,_,_) = v in g
  let get_7_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'h = let (_,_,_,_,_,_,_,h,_,_) = v in h
  let get_8_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'i = let (_,_,_,_,_,_,_,_,i,_) = v in i
  let get_9_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'j = let (_,_,_,_,_,_,_,_,_,j) = v in j

  (* storage update *)
  val update_storage 's 'a 'a : 's
  val update_record 'a 'a : 's
  val update_simple 's 'a : 's

  val to_key ('a, 'b) : 'a
  val to_val ('a, 'b) : 'b

end

theory Msg

  type msg

  val required                 unit : msg
  val not_accept_transfer      unit : msg
  val not_found                unit : msg
  val check_condition_failed   unit : msg
  val not_valid_state          unit : msg
  val not_supported_yet        unit : msg
  val already_exists           unit : msg
  val not_authorized_fun       unit : msg
  val not_valid_condition      unit : msg

end

theory Current

  use Address
  use Timestamp
  use Tez
  use Msg

  val sender   unit   : address
  val balance  unit   : tez
  val amount   unit   : tez
  val time_    unit   : timestamp

  exception Side

  val failwith msg  : 'a raises { Side }

  let get_caller = sender

  let now = time_

end

theory List

  use export list.List
  use option.Option

  use Nat

  val mem ('a, list 'a) : option 'a

  val add ('a, list 'a) : list 'a

  val remove ('a, list 'a) : list 'a

  val append (list 'a, list 'a) : list 'a

  val fold (('e, 'acc) -> 'acc) (list 'e) 'acc : 'acc

  val list_when ('s, ('s , 'a) -> bool, list 'a) : list 'a

  val sum_nat ('s, ('s , 'a) -> nat, list 'a) : nat

end

module Types

  use export Int
  use export Nat
  use export String
  use export Timestamp
  use export Tez
  use export Address
  use export List

end

theory Map

  use option.Option

  use Types

  type map 'a 'b

  val find 'a (map 'a 'b) : option 'b

  val mem 'a (map 'a 'b) : bool

  val add 'a 'b (map 'a 'b) : map 'a 'b

  val remove 'a (map 'a 'b) : map 'a 'b

  val update 'a (option 'b) (map 'a 'b) : map 'a 'b

  val fold ((('a, 'b), 'c) -> 'c) (map 'a 'b) 'c : 'c

  val empty_map unit : map 'a 'b

end

theory Set

  use Types

  type set 'a

  val mem 'a (set 'a) : bool

  val add 'a (set 'a) : set 'a

  val remove 'a (set 'a) : set 'a

  val empty_set unit : set 'a

end


theory Contract

  use list.List

  use Address
  use Tez

  type operation = {
     destination : key_hash;
     amount      : tez;
  }

 let empty_ops : list operation = Nil

 val transfer key_hash tez : operation

end
