theory Int

  use export int.Int

  val int_eq int int : bool
  val int_nq int int : bool
  val int_ge int int : bool
  val int_le int int : bool
  val int_gt int int : bool
  val int_lt int int : bool

  val mk_int int : int

end

theory Nat

  use int.Int

  type nat

  val nat_eq nat nat : bool
  val nat_nq nat nat : bool

  val nat_ge nat nat : bool
  val nat_le nat nat : bool
  val nat_gt nat nat : bool
  val nat_lt nat nat : bool

  val nat_plus  nat nat : nat
  val nat_sub (nat, nat) : nat

  val nat_zero () : nat
  val nat_one  () : nat

  val mk_nat Int.int : nat

end

theory Uint

  type uint

end

theory Address

  type address

  val add_eq address address : bool
  val add_nq address address : bool

end

theory Timestamp

  type timestamp

  val tim_eq timestamp timestamp : bool
  val tim_nq timestamp timestamp : bool

  val tim_ge timestamp timestamp : bool
  val tim_le timestamp timestamp : bool
  val tim_gt timestamp timestamp : bool
  val tim_lt timestamp timestamp : bool

end

theory Tez

  type tez

end

theory String

  type string

  val str_eq string string : bool

end

theory Utils

  use int.Int
  use list.List

  val sort ((('a , 'a) -> int) , list 'a) : list 'a

  (* tuple *)
  let get_0_2 (v : ('a , 'b)) : 'a = let (a,_) = v in a
  let get_1_2 (v : ('a , 'b)) : 'b = let (_,b) = v in b

  let get_0_3 (v : ('a , 'b , 'c)) : 'a = let (a,_,_) = v in a
  let get_1_3 (v : ('a , 'b , 'c)) : 'b = let (_,b,_) = v in b
  let get_2_3 (v : ('a , 'b , 'c)) : 'c = let (_,_,c) = v in c

  let get_0_4 (v : ('a , 'b , 'c , 'd)) : 'a = let (a,_,_,_) = v in a
  let get_1_4 (v : ('a , 'b , 'c , 'd)) : 'b = let (_,b,_,_) = v in b
  let get_2_4 (v : ('a , 'b , 'c , 'd)) : 'c = let (_,_,c,_) = v in c
  let get_3_4 (v : ('a , 'b , 'c , 'd)) : 'd = let (_,_,_,d) = v in d

  let get_0_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'a = let (a,_,_,_,_) = v in a
  let get_1_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'b = let (_,b,_,_,_) = v in b
  let get_2_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'c = let (_,_,c,_,_) = v in c
  let get_3_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'd = let (_,_,_,d,_) = v in d
  let get_4_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'e = let (_,_,_,_,e) = v in e

  let get_0_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'a = let (a,_,_,_,_,_) = v in a
  let get_1_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'b = let (_,b,_,_,_,_) = v in b
  let get_2_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'c = let (_,_,c,_,_,_) = v in c
  let get_3_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'd = let (_,_,_,d,_,_) = v in d
  let get_4_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'e = let (_,_,_,_,e,_) = v in e
  let get_5_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'f = let (_,_,_,_,_,f) = v in f

  let get_0_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'a = let (a,_,_,_,_,_,_) = v in a
  let get_1_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'b = let (_,b,_,_,_,_,_) = v in b
  let get_2_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'c = let (_,_,c,_,_,_,_) = v in c
  let get_3_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'd = let (_,_,_,d,_,_,_) = v in d
  let get_4_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'e = let (_,_,_,_,e,_,_) = v in e
  let get_5_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'f = let (_,_,_,_,_,f,_) = v in f
  let get_6_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'g = let (_,_,_,_,_,_,g) = v in g

  (* storage update *)
  val update_storage 's 'a 'a : 's

end

theory Msg

  type msg

  val not_found unit : msg

end

theory Current

  use Address
  use Timestamp
  use Msg

  val sender   unit   : address
  val time     unit   : timestamp

  val failwith msg  : 'a

  let get_caller = sender

  let now = time

end

theory List

  use export list.List
  use option.Option

  use Nat

  val mem ('a, list 'a) : option 'a

  val add ('a, list 'a) : list 'a

  val remove ('a, list 'a) : list 'a

  val append (list 'a, list 'a) : list 'a

  val fold (('e, 'acc) -> 'acc) (list 'e) 'acc : 'acc

  val list_when ('s, ('s , 'a) -> bool, list 'a) : list 'a

  val sum_nat ('s, ('s , 'a) -> nat, list 'a) : nat

end

module Types

  use export Int
  use export Nat
  use export String
  use export Timestamp
  use export Tez
  use export Address
  use export List

end

theory Map

  use option.Option

  use Types

  type map 'a 'b

  val find 'a (map 'a 'b) : option 'b

  val add 'a 'b (map 'a 'b) : map 'a 'b

  val remove 'a (map 'a 'b) : map 'a 'b

  val empty_map_str_int unit : map string int
  val empty_map_str_nat unit : map string nat
  val empty_map_str_tim unit : map string timestamp
  val empty_map_str_add unit : map string address
  val empty_map_str_str unit : map string string
  val empty_map_str_tez unit : map string tez

  val empty_map_add_int unit : map address int
  val empty_map_add_nat unit : map address nat
  val empty_map_add_tim unit : map address timestamp
  val empty_map_add_add unit : map address address
  val empty_map_add_str unit : map address string
  val empty_map_add_tez unit : map address tez

  val empty_map_str_intl unit : map string (list int)
  val empty_map_str_natl unit : map string (list nat)
  val empty_map_str_timl unit : map string (list timestamp)
  val empty_map_str_addl unit : map string (list address)
  val empty_map_str_strl unit : map string (list string)
  val empty_map_str_tezl unit : map string (list tez)

  val empty_map_add_intl unit : map address (list int)
  val empty_map_add_natl unit : map address (list nat)
  val empty_map_add_timl unit : map address (list timestamp)
  val empty_map_add_addl unit : map address (list address)
  val empty_map_add_strl unit : map address (list string)
  val empty_map_add_tezl unit : map address (list tez)

end

theory Set

  use Types

  type set 'a

  val mem 'a (set 'a) : bool

  val add 'a (set 'a) : set 'a

  val remove 'a (set 'a) : set 'a

  val empty_set_int unit : set int
  val empty_set_nat unit : set nat
  val empty_set_tim unit : set timestamp
  val empty_set_add unit : set address
  val empty_set_str unit : set string
  val empty_set_tez unit : set tez

end


theory Contract

  use list.List

  use Address
  use Tez

  type operation = {
     destination : address;
     amount      : tez;
 }

 let empty_ops : list operation = Nil

end
