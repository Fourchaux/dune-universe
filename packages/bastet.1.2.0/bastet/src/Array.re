open Interface;
let (get, length) = ArrayLabels.(get, length);

let zip_with: (('a, 'b) => 'c, array('a), array('b)) => array('c) =
  (f, xs, ys) => {
    let l = length(xs) < length(ys) ? length(xs) : length(ys)
    and index = ref(0)
    and result = ref(None);

    for (i in 0 to l - 1) {
      let value = f(get(xs, i), get(ys, i));
      switch (result^) {
      | Some(arr) => ArrayLabels.set(arr, index^, value)
      | None => result := Some(ArrayLabels.make(l, value))
      };
      index := index^ + 1;
    };
    switch (result^) {
    | Some(array) => array
    | None => [||]
    };
  };

let zip: (array('a), array('b)) => array('c) =
  (xs, ys) => zip_with((a, b) => (a, b), xs, ys);

module type EQ_F = (E: EQ) => EQ with type t = array(E.t);
module type ORD_F = (O: ORD) => ORD with type t = array(O.t);
module type SHOW_F = (S: SHOW) => SHOW with type t = array(S.t);
module type TRAVERSABLE_F =
  (A: APPLICATIVE) =>

    TRAVERSABLE with
      type t('a) = array('a) and type applicative_t('a) = A.t('a);

module Functor: FUNCTOR with type t('a) = array('a) = {
  type t('a) = array('a);
  let map = f => ArrayLabels.map(~f);
};

module Apply: APPLY with type t('a) = array('a) = {
  include Functor;
  let apply = (fn_array, a) =>
    ArrayLabels.fold_left(
      ~f=(acc, f) => ArrayLabels.append(acc, map(f, a)),
      ~init=[||],
      fn_array,
    );
};

module Applicative: APPLICATIVE with type t('a) = array('a) = {
  include Apply;
  let pure = a => [|a|];
};

module Monad: MONAD with type t('a) = array('a) = {
  include Applicative;
  let flat_map = (x, f) =>
    ArrayLabels.fold_left(
      ~f=(acc, a) => ArrayLabels.append(acc, f(a)),
      ~init=[||],
      x,
    );
};

module Alt: ALT with type t('a) = array('a) = {
  include Functor;
  let alt = (a, b) => ArrayLabels.append(b, a);
};

module Foldable: FOLDABLE with type t('a) = array('a) = {
  type t('a) = array('a);

  let fold_left = (f, init) => ArrayLabels.fold_left(~f, ~init)
  and fold_right = (f, init) => ArrayLabels.fold_right(~f, ~init);

  module Fold_Map = (M: MONOID) => {
    module D =
      Default.Fold_Map(
        M,
        {
          type t('a) = array('a);
          let (fold_left, fold_right) = (fold_left, fold_right);
        },
      );
    let fold_map = D.fold_map_default_left;
  };
  module Fold_Map_Any = (M: MONOID_ANY) => {
    module D =
      Default.Fold_Map_Any(
        M,
        {
          type t('a) = array('a);
          let (fold_left, fold_right) = (fold_left, fold_right);
        },
      );
    let fold_map = D.fold_map_default_left;
  };
  module Fold_Map_Plus = (P: PLUS) => {
    module D =
      Default.Fold_Map_Plus(
        P,
        {
          type t('a) = array('a);
          let (fold_left, fold_right) = (fold_left, fold_right);
        },
      );
    let fold_map = D.fold_map_default_left;
  };
};

module Unfoldable: UNFOLDABLE with type t('a) = array('a) = {
  type t('a) = array('a);

  let rec unfold = (f, init) =>
    switch (f(init)) {
    | Some((a, next)) => ArrayLabels.concat([[|a|], unfold(f, next)])
    | None => [||]
    };
};

module Traversable: TRAVERSABLE_F =
  (A: APPLICATIVE) => {
    type t('a) = array('a)
    and applicative_t('a) = A.t('a);

    include (Functor: FUNCTOR with type t('a) := t('a));
    include (Foldable: FOLDABLE with type t('a) := t('a));

    module I = Infix.Apply(A);

    let traverse = f =>
      I.(
        ArrayLabels.fold_right(
          ~f=
            (acc, x) =>
              A.pure((x, y) => ArrayLabels.append([|x|], y))
              <*> f(acc)
              <*> x,
          ~init=A.pure([||]),
        )
      );

    module D =
      Default.Sequence({
        type t('a) = array('a)
        and applicative_t('a) = A.t('a);
        let traverse = traverse;
      });

    let sequence = D.sequence_default;
  };

module Eq: EQ_F =
  (E: EQ) => {
    type t = array(E.t);
    let eq = (xs, ys) =>
      length(xs) == length(ys)
      && ArrayLabels.for_all(~f=((a, b)) => E.eq(a, b), zip(xs, ys));
  };

module Ord: ORD_F =
  (O: ORD) => {
    include Eq(O);
    let compare = (xs, ys) =>
      switch (xs, ys) {
      | _ when length(xs) == length(ys) =>
        let index = ref(0);
        ArrayLabels.fold_left(
          ~f=
            (acc, e) => {
              let result =
                acc != `equal_to ? acc : O.compare(e, get(ys, index^));
              index := index^ + 1;
              result;
            },
          ~init=`equal_to,
          xs,
        );
      | _ when length(xs) < length(ys) => `less_than
      | _ => `greater_than
      };
  };

module Show: SHOW_F =
  (S: SHOW) => {
    module F = Functions.Foldable(Foldable);
    module M = F.Monoid(String.Monoid);

    type t = array(S.t);
    let show = xs =>
      "[" ++ M.intercalate(~separator=", ", Functor.map(S.show, xs)) ++ "]";
  };

module Invariant: INVARIANT with type t('a) = array('a) = {
  type t('a) = array('a);
  let imap = (f, _) => Functor.map(f);
};

module Extend: EXTEND with type t('a) = array('a) = {
  include Functor;
  let extend = (f, xs) =>
    ArrayLabels.mapi(
      ~f=(i, _) => f(ArrayLabels.sub(xs, ~pos=i, ~len=length(xs) - i)),
      xs,
    );
};

module Infix = {
  include Infix.Monad(Monad);
  include Infix.Extend(Extend);
};
