---
id: introduction
title: What is coq-of-ocaml
---

coq-of-ocaml is a compiler from the [OCaml](https://ocaml.org/) programming language to the [Coq](https://coq.inria.fr/) proof language. It aims generate *idiomatic* and *human readable* OCaml code doing a *shallow embedding*.

We can use coq-of-ocaml to:
* do formal proofs on OCaml programs;
* port OCaml projects to Coq. 

Starting from the following OCaml program:
```ocaml
type 'a tree =
  | Leaf of 'a
  | Node of 'a tree * 'a tree

let rec sum tree =
  match tree with
  | Leaf n -> n
  | Node (tree1, tree2) -> sum tree1 + sum tree2
```
we get the following Coq program:
```coq
(* Generated by coq-of-ocaml *)
Inductive tree (a : Set) : Set :=
| Leaf : a -> tree a
| Node : (tree a) -> (tree a) -> tree a.

Arguments Leaf {_}.
Arguments Node {_}.

Fixpoint sum (tree : tree Z) : Z :=
  match tree with
  | Leaf n => n
  | Node tree1 tree2 => Z.add (sum tree1) (sum tree2)
  end.
```

## Concepts
We import the purely functional part of OCaml to Coq. We keep the side-effects as axioms. We may not completely preserve the semantics of the source code. One should do manual reviews to assert that the generated Coq is a reasonable formalization of the sources. We generate a dummy Coq term and an explicit error message in case of error, so that we always generate something.

We compile OCaml projects by pluging into [Merlin](https://github.com/ocaml/merlin). This means that if you are using Merlin then you can run `coq-of-ocaml` with no additional configurations.

We do not do special treatments for the termination of fixpoints. We disable termination checks by using the package [coq-typing-flags](https://github.com/SimonBoulier/TypingFlags) from [Simon Boulier](http://perso.eleves.ens-rennes.fr/people/Simon.Boulier/) (should be included in the upcoming Coq 8.11). We erase the type parameters for the [GADTs](https://caml.inria.fr/pub/docs/manual-ocaml/manual033.html). This makes sure that the type definitions are accepted, but can make the pattern matchings incomplete. We did not find a way to nicely represent GADTs in Coq yet. We think that this is hard because the dependent pattern matching works well on type indicies which are values, but does not with types.

We support modules, module types, functors and first-class modules. We generate either Coq modules or dependent records depending on the use case. We generate axioms for `.mli` files to help formalizations, but importing `.mli` files should be optional. The generation of the `Require` primitives to import other Coq files should be done by hand.

## Status
coq-of-ocaml is under active development at [Nomadic Labs](https://www.nomadic-labs.com/) to get a [Coq formalization](https://clarus.github.io/coq-of-ocaml/examples/tezos/) of the [Tezos](https://tezos.com/) crypto-currency. Use the development version from the `master` branch to get the latest features. Do not hesitate to ask questions on our Gitter [chat room](https://gitter.im/clarus/coq-of-ocaml).

## Workflow
coq-of-ocaml works by compiling files one by one. Thanks to Merlin we get access to the typing environment of each file, so names referencing external modules are properly interpreted.

In a typical project, we may want to translate some of the `.ml` and keep the rest as axioms (for the libraries or non-critical files). To generate the axioms, we can run coq-of-ocaml on the `.mli` files of parts we want to abstract. We do not generate the `Require` directives at the start of the files, and need to add them by hand. Depending on the extend of what we want to formalize, we can either require other imported `.ml` files, the interface files of axioms for the `.mli` or custom files.

When something is not properly handled, coq-of-ocaml generates an error message. These errors do not necessarily need to be fixed. However, there are good warnings to help having a more extensive and reliable Coq formalization by updating the OCaml source code.

Generally, the generated Coq for a project does not compile as it is. This can be due to unsupported OCaml features, or various small errors such as name collisions. In this case, you can:
* modify the OCaml input code, so that it fits what coq-of-ocaml handles or avoids Coq errors (follow the error messages);
* use the [attributes](attributes) or [configuration](configuration) mechanism to customize the translation of coq-of-ocaml;
* fork coq-of-ocaml to modify the code translation;
* post-process the output with a script;
* post-process the output by hand.

## Related
In the OCaml community:
* [CFML](http://chargueraud.org/softs/cfml/) (import OCaml to Coq using characteristic formulae)
* [coq-of-ocaml-mrmr1993](https://github.com/mrmr1993/coq-of-ocaml) (fork of coq-of-ocaml including side-effects, focusing on the compilation of the OCaml's stdlib)

In the JavaScript community:
* [coq-of-js](https://github.com/clarus/coq-of-js) (under heavy development, contributors needed! sister project; *currently on halt to support coq-of-ocaml*)

In the Haskell community:
* [hs-to-coq](https://github.com/antalsz/hs-to-coq) (import Haskell to Coq)
* [hs-to-gallina](https://github.com/gdijkstra/hs-to-gallina) (2012, by Gabe Dijkstra, first known project to do a shallow embedding of a mainstream functional programming language to Coq)

## Credits
The coq-of-ocaml project started as part of a PhD directed by [Yann Regis-Gianas](http://yann.regis-gianas.org/) and [Hugo Herbelin
](http://pauillac.inria.fr/~herbelin/) as the university of [Paris 7](https://u-paris.fr/). Originally, the goal was to formalize real OCaml programs in Coq to study side-effects inference and proof techniques on functional programs. The project is now financed by [Nomadic Labs](https://www.nomadic-labs.com/) to formalize the implementation of the crypto-currency [Tezos](https://tezos.com/).
