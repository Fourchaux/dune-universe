(* This file has been autogenerated by mir-crunch *)
module Internal = struct
let file_chunks = function
 | "about-proj.md" | "/about-proj.md" -> Some ["!!The Project\n\nWe are grateful to funding by the RCUK Horizon Digital Economy Research Hub grant, EP/G065802/1.\n\nAmazon also gave us an [Amazon in Education](http://aws.amazon.com/education/) award to help test on EC2.\n\nVerisign is [sponsoring](http://www.cl.cam.ac.uk/news/2011/03/anil-madhavapeddy-wins-verisign-grant/) work on the secure DNS library.\n\n" ]
 | "about-r.md" | "/about-r.md" -> Some ["!!The Channels\n\n* *E-mail*: developer mailing list at [lists.cam.ac.uk](https://lists.cam.ac.uk/mailman/listinfo/cl-mirage) and [archive](https://lists.cam.ac.uk/pipermail/cl-mirage/)\n* *IRC*: `#mirage` on `irc.freenode.org`\n* *Twitter*: [openmirage](http://twitter.com/openmirage)\n* *Meetings*: [Kingston Arms](http://www.kingston-arms.co.uk/)\n" ]
 | "about.md" | "/about.md" -> Some ["!!The Crew\n\n* *Anil Madhavapeddy*, University of Cambridge, [anil.recoil.org](http://anil.recoil.org)\n* *Thomas Gazagnaire*, OCamlPro, [thomas.gazagnaire.org](http://thomas.gazagnaire.org)\n* *Richard Mortier*, University of Nottingham, [cs.nott.ac.uk](http://www.cs.nott.ac.uk/~rmm/)\n* *David Scott*, Citrix Systems R&D, [dave.recoil.org](http://dave.recoil.org)\n* *Raphael Proust*, University of Cambridge\n* *Haris Rotsos*, University of Cambridge, [cl.cam.ac.uk](http://www.cl.cam.ac.uk/~cr409/)\n* *Balraj Singh*, University of Cambridge\n* *Jon Crowcroft*, University of Cambridge, [cl.cam.ac.uk](http://www.cl.cam.ac.uk/~jac22/)\n* *Steven Hand*, University of Cambridge, [cl.cam.ac.uk](http://www.cl.cam.ac.uk/~smh22/)\n* *Vincent Bernardoff*, Citrix Systems R&D\n* *Jon Ludlam*, Citrix Systems R&D\n\n!!The Project\n\nWe acknowledge funding from the RCUK Horizon Digital Economy Research Hub grant, EP/G065802/1.\nAmazon also granted us an [Amazon in Education](http://aws.amazon.com/education/) award to test on EC2, and Verisign [sponsored](http://www.cl.cam.ac.uk/news/2011/03/anil-madhavapeddy-wins-verisign-grant/) work on the secure DNS library.\n" ]
 | "arch.md" | "/arch.md" -> Some ["To build network servers in Mirage, you need to understand three concepts:\n\n* *Concurrency* is handled using co-operative threads, which means that your application must explicitly yield control to other threads. These threads are very light-weight, and thus this model works well for parallel I/O.\n\n* *Networking* traffic is fed to the application via [lens buffers](/code/len), which are data structures designed for zero-copy parsing and construction of wire traffic. Mirage provides several methods to make it easy to parse binary protocols (e.g. Ethernet, TCP/IP or BGP), text protocols (e.g. ABNF grammers for HTTP or IMAP), and data formats like XML or JSON.\n\n* *Storage* is provided via an ORM extension which lets native OCaml types be saved and queried.  Some backends are relational ([SQLite](http://sqlite.org/)) and others purely functional with permanent history (e.g. the git or block-based backends).\n" ]
 | "blog/an-outing-to-cufp.md" | "/blog/an-outing-to-cufp.md" -> Some ["The team signed up to do a tutorial at [CUFP](http://cufp.org) on the topic of [Building a Functional OS](http://cufp.org/conference/sessions/2011/t3-building-functional-os), which meant zooming off to Tokyo!  This was the first public show of the project, and resulted in a furious [flurry of commits](https://github.com/avsm/mirage/graphs/impact) from the whole team to get it ready. The 45-strong crowd at the tutorial were really full of feedback, and particular thanks to [Michael](http://www.deinprogramm.de/sperber/) for organising the event, and [Yaron](http://ocaml.janestreet.com/?q=blog/5), [Marius](http://monkey.org/~marius/), [Steve](https://twitter.com/#!/stevej), [Wil](https://twitter.com/wil), [Adrian](https://twitter.com/#!/adoemon) and the rest for shouting out questions regularly!\n\n* *The tutorial* is [a Mirage application](http://github.com/avsm/mirage-tutorial), so you can clone it and view it locally through your web browser. The content is mirrored at [tutorial.openmirage.org](http://tutorial.openmirage.org), although it does require cleanup to make it suitable to an online audience. The SVG integration is awkward and it only works on Chrome/Safari, so I will probably rewrite it using [deck.js](http://imakewebthings.github.com/deck.js/) soon. The tutorial is a good showcase of Mirage, as it compiles to Xen, UNIX (both kernel sockets and direct tuntap) with a RAMdisk or external filesystem, and is a good way to mess around with application synthesis (look at the `Makefile` targets in `slides/`).\n\n* *Installation*: [instructions](/wiki/install) have been simplified, and we now only require OCaml on the host and include everything else in-tree. Thomas has also made Emacs and Vim plugins that are compatible with the ocamlbuild layout.\n\n* *Lwt*: a [new tutorial](/wiki/tutorial-lwt) which walks you through the cooperative threading library we use, along with exercises (all available in [mirage-tutorial](http://github.com/avsm/mirage-tutorial)). Raphael and Balraj are looking for feedback on this, so get in touch!\n\n* *Javascript*: via [node.js](http://nodejs.org) did not work in time for the tutorial, as integrating I/O is a tangled web that will take some time to sort out. Raphael is working on this in a [separate tree](https://github.com/raphael-proust/nodejs_of_ocaml) for now.  As part of this effort though, he integrated a pure OCaml [regular expression library](/wiki/ocaml-regexp) that does not require C bindings, and is surprisingly fast.\n\n* *Devices*: we can now synthesise binaries that share common code but have very different I/O interfaces. This is due to a new device manager, and David also heroically wrote a complete [FAT12/16/32 library](http://github.com/avsm/mirage/tree/master/lib/fs) that we demonstrated.  Yaron Minsky suggested a [different approach](https://gist.github.com/1245418) to the device manager using [first-class modules](http://caml.inria.fr/pub/docs/manual-ocaml/manual021.html#toc81) instead of objects, so I am experimentally trying this before writing documentation on it.\n\n* *TCP*: the notorious Mirage stack is far more robust due to our resident networking guru Balraj hunting down last-minute bugs. Although it held together with sticky tape during the tutorial, he is now adding retransmission and congestion control to make it actually standards-compliant.  Still, if you dont have any packet loss, the [microkernel version](http://xen.openmirage.org/) of this website does actually serve pages.\n\n* *OpenFlow*: is a new [standard](http://www.openflow.org/wk/index.php/OpenFlow_v1.0) for [Software Defined Networking](http://networkheresy.wordpress.com/), and Haris and Mort have been hacking away at a complete implementation directly in Mirage!  We will be giving a tutorial on this at the [OFELIA summer school](http://changeofelia.info.ucl.ac.be/) in November (it is summer somewhere, I guess). The prospect of a high-speed microkernel switching fabric for the cloud, programmed in a functional style, is something I am really looking forward to seeing!\n\n* *Jane Street Core*: preceeding us was";
" Yaron's [Core](http://cufp.org/conference/sessions/2011/t2-janestreets-ocaml-core-library) tutorial. Since Mirage provides it own complete standard library, we can adopt portions of Core that do not require OS threads or UNIX-specific features.  I really like the idea that Mirage enforces a discipline on writing portable interfaces, as dependencies on OS-specific features do sneak in insiduously and make switching to different platforms very difficult (e.g. Windows support). Incidentally, Yaron's [ACM Queue](http://queue.acm.org/detail.cfm?id=2038036&ref=fullrss) article is a great introduction to OCaml.\n\nSo as you can see, it has been a busy few months!  Much of the core of Mirage is settling down now, and we are writing a paper with detailed performance benchmarks of our various backends.  Keep an eye on the [Github milestone](https://github.com/avsm/mirage/issues?milestone=2&state=open) for the preview release, join our [new mailing list](https://lists.cam.ac.uk/mailman/listinfo/cl-mirage), or follow the newly sentient [openmirage on twitter](http://twitter.com/openmirage)!\n" ]
 | "blog/announcing-mirage-openflow.md" | "/blog/announcing-mirage-openflow.md" -> Some ["Something we've been working on for a little while now that we're pretty\nexcited about is an [OpenFlow](http://openflow.org/) implementation for\nMirage. For those who're not networking types, in short, OpenFlow is a\nprotocol and framework for devolving network control to software running on\nplatforms other than the network elements themselves. It consists of three\nmain parts:\n\n* a *controller*, responsible for exercising control over the network;\n* *switches*, consisting of switching hardware, with flow tables that apply\n  forwarding behaviours to matching packets; and\n* the *protocol*, by which controllers and switches communicate.\n\nFor more -- and far clearer! -- explanations, see any of the many online\nOpenFlow resources such as [OpenFlowHub](http://openflowhub.org).\n\nWithin Mirage we have an OpenFlow implementation in two parts: individual\nlibraries that provide controller and switch functionality. Linking the switch\nlibrary enables your application to become a software-based OpenFlow switch.\nLinking in the controller library enables your application to exercise direct\ncontrol over OpenFlow network elements. \n\nThe controller is modelled after the [NOX](http://noxrepo.org/) open-source\ncontroller and currently provides only relatively low-level access to the\nOpenFlow primitives: a very cool thing to build on top of it would be a\nhigher-level abstraction such as that provided by\n[Nettle](http://haskell.cs.yale.edu/?page_id=376) or\n[Frenetic](http://www.frenetic-lang.org/).\n\nThe switch is primarily intended as an experimental platform -- it is\nhopefully easier to extend than some of the existing software switches while\nstill being sufficiently high performance to be interesting! \n\nBy way of a sample of how it fits together, here's a skeleton for a simple\ncontroller application:\n\n```\ntype mac_switch = {\n  addr: OP.eaddr; \n  switch: OP.datapath_id;\n}\n\ntype switch_state = {\n  mutable mac_cache: \n        (mac_switch, OP.Port.t) Hashtbl.t;\n  mutable dpid: OP.datapath_id list\n}\n\nlet switch_data = {\n  mac_cache = Hashtbl.create 7; \n  dpid = [];\n} \n\nlet join_cb controller dpid evt =\n  let dp = match evt with\n      | OE.Datapath_join c -> c\n      | _ -> invalid_arg \"bogus datapath_join\"\n  in \n  switch_data.dpid <- switch_data.dpid @ [dp]\n\nlet packet_in_cb controller dpid evt =\n  (* algorithm details omitted for space *)\n\nlet init ctrl = \n  OC.register_cb ctrl OE.DATAPATH_JOIN join_cb;\n  OC.register_cb ctrl OE.PACKET_IN packet_in_cb\n\nlet main () =\n  Net.Manager.create (fun mgr interface id ->\n    let port = 6633 in \n    OC.listen mgr (None, port) init\n  )\n```\n\nWe've written up some of the gory details of the design, implementation and\nperformance in a [short paper](/docs/iccsdn12-mirage.pdf) to the\n[ICC](http://www.ieee-icc.org/)\n[Software Defined Networking](http://sdn12.mytestbed.net/) workshop. Thanks to\nsome sterling work by [Haris](http://www.cl.cam.ac.uk/~cr409/) and\n[Balraj](mailto:balraj.singh@cl.cam.ac.uk), the headline numbers are pretty\ngood though: the unoptimised Mirage controller implementation is only 30--40%\nlower performance than the highly optimised NOX *destiny-fast* branch, which\ndrops most of the programmability and flexibility of NOX; but is about *six\ntimes* higher performance than the fully flexible current NOX release. The\nswitch's performance  running as a domU virtual machine is indistinguishable\nfrom the current [Open vSwitch](http://openvswitch.org/) release.\n\nFor more details see [the paper](/docs/iccsdn12-mirage.pdf) or contact\n[Mort](mailto:mort@cantab.net),\n[Haris](mailto:charalampos.rotsos@cl.cam.ac.uk) or\n[Anil](mailto:anil@recoil.org). Please do get in touch if you've any comments\nor questions, or you do anything interesting with it!\n" ]
 | "blog/breaking-up-with-opam.md" | "/blog/breaking-up-with-opam.md" -> Some ["When we first started developing Mirage in 2009, we were rewriting huge chunks of operating system and runtime code in OCaml. This ranged from low-level device drivers to higher-level networking protocols such as TCP/IP or HTTP.  The changes weren't just straight rewrites of C code either, but also involved experimenting with interfaces such as iteratees and [lightweight threading](/wiki/tutorial-lwt) to take advantage of OCaml's static type system.  To make all of this easy to work with, we decided to lump everything into a [single Git repository](http://github.com/avsm/mirage) that would bootstrap the entire system with a single `make` invocation.\n\nNowadays though, Mirage is self-hosting, the interfaces are settling down, the number of libraries are growing every day, and portions of it are being used in [the Xen Cloud Platform](/blog/xenstore-stub-domain). So for the first developer release, we wanted to split up the monolithic repository into more manageable chunks, but still make it as easy as possible for the average OCaml developer to try out Mirage.\n\nThanks to much hard work from [Thomas](http://gazagnaire.org) and his colleagues at [OCamlPro](http://ocamlpro.com), we now have [OPAM](http://opam.ocamlpro.com): a fully-fledged package manager for Mirage!  OPAM is a source-based package manager that supports a growing number of community OCaml libraries.  More importantly for Mirage, it can also switch between multiple compiler installations, and so support cross-compiled runtimes and modified standard libraries.\n\nOPAM includes compiler variants for Mirage-friendly environments for Xen and the UNIX `tuntap` backends.  The [installation instructions](/wiki/install) now give you instructions on how to use OPAM, and the old monolithic repository is considered deprecated.  We're still working on full documentation for the first beta release, but all the repositories are on the [Mirage organisation](http://github.com/mirage) on Github, with some of the important ones being:\n\n* [mirage-platform](http://github.com/mirage/mirage-platform) has the core runtime for Xen and UNIX, implemented as the `OS` module.\n* [mirage-net](http://github.com/mirage/mirage-net) has the TCP/IP networking stack.\n* [ocaml-cstruct](http://github.com/mirage/ocaml-cstruct) has the camlp4 extension to manipulate memory like C `struct`s, but with type-safe accessors in OCaml.\n* [ocaml-xenstore](http://github.com/mirage/ocaml-xenstore) has a portable implementation of the Xenstore protocol to communicate with the Xen management stack from a VM (or even act as a [server in a stub domain](/blog/xenstore-stub-domain)).\n* [ocaml-dns](http://github.com/mirage/ocaml-dns) is a pure OCaml implementation of the DNS protocol, including a server and stub resolver.\n* [ocaml-re](http://github.com/mirage/ocaml-re) is a pure OCaml version of several regular expression engines, including Perl compatibility.\n* [ocaml-uri](http://github.com/mirage/ocaml-uri) handles parsing the surprisingly complex URI strings.\n* [ocaml-cohttp](http://github.com/mirage/ocaml-cohttp) is a portable HTTP parser, with backends for Mirage, Lwt and Core/Async. This is a good example of how to factor out OS-specific concerns using the OCaml type system (and I plan to blog more about this soon).\n* [ocaml-cow](http://github.com/mirage/ocaml-cow) is a set of syntax extensions for JSON, CSS, XML and XHTML, which are explained [here](/wiki/cow), and used by this site.\n* [ocaml-dyntype](http://github.com/mirage/dyntype) uses camlp4 to [generate dynamic types](http://anil.recoil.org/papers/2011-dynamics-ml.pdf) and values from OCaml type declarations.\n* [ocaml-orm](http://github.com/mirage/orm) auto-generates SQL scheme from OCaml types via Dyntype, and currently supports SQLite.\n* [ocaml-openflow](http://github.com/mirage/ocaml-openflow) implements an OCaml switch and controller for the Openflow protocol.\n\nThere are quite a few more that are still being hacked for release by the team, but we're getting there very fast now. We also have the Mirage ports of [SSH](http://github.com/avsm/ocaml-ssh) to";
" integrate before the first release this year, and Haris has got some [interesting DNSSEC](http://github.com/mirage/ocaml-crypto-keys) code!  If you want to get involved, join the [mailing list](/about) or IRC channel!\n" ]
 | "blog/spring-cleaning.md" | "/blog/spring-cleaning.md" -> Some ["We've been plugging away on Mirage for the last few months, and things are starting to take shape nicely. As the older blog entries were out-of-date, we have shifted the descriptive material to a new [wiki](/wiki) section instead. What else has been happening?\n\n* The Xen microkernel backend is fully event-driven (no interrupts) and very stable under stress testing now. The TCP stack is also complete enough to self-host this website, and you can try it out by navigating to [xen.openmirage.org](http://xen.openmirage.org). The stack doesnt actually do retransmissions yet, so your user experience may \"vary\". Check out the [installation](/wiki/install) and [hello world](/wiki/hello-world) guides to try it out for yourself.\n* [Richard Mortier](http://www.cs.nott.ac.uk/~rmm/) has put together a performance testing framework that lets us analyse the performance of Mirage applications on different backends (e.g. UNIX vs Xen), and against other conventional applications (e.g. BIND for DNS serving). Read more in the wiki [here](/wiki/performance).\n* [Thomas Gazagnaire](http://gazagnaire.org) has rewritten the website to use the COW syntax extensions. He has also started a new job with [OCamlPro](http://www.ocamlpro.com/) doing consultancy on OCaml, so congratulations are in order!\n* Thomas has also started integrating experimental Node.js support to fill in our buzzword quota for the year (and more seriously, to explore alternative VM backends for Mirage applications). \n* The build system (often a bugbear of such OS projects) now fully uses [ocamlbuild](http://brion.inria.fr/gallium/index.php/Ocamlbuild) for all OCaml and C dependencies, and so the whole OS can be rebuilt with different compilers (e.g. LLVM) or flags with a single invocation.\n\nThere are some exciting developments coming up later this year too!\n\n* [Raphael Proust](https://github.com/raphael-proust) will be joining the Mirage team in Cambridge over the summer in an internship.\n* Anil Madhavapeddy will be giving several [tech talks](/wiki/talks) on Mirage: at the [OCaml User's Group](https://forge.ocamlcore.org/plugins/mediawiki/wiki/ocaml-meeting/index.php/OCamlMeeting2011) in Paris this Friday, at [Acunu](http://acunu.com) in London on May 31st, and at Citrix Cambridge on June 3rd. If you are interested, please do drop by and say hi.\n* Verisign has supported the project with an [Internet Infrastructure Grant](http://www.marketwire.com/press-release/Verisign-Announces-Winners-of-Grants-Aimed-at-Strengthening-Internet-Infrastructure-NASDAQ-VRSN-1412893.htm).\n* [David Scott](http://dave.recoil.org) (chief architect of the Xen Cloud Platform) and [Anil Madhavapeddy](http://anil.recoil.org) will give a joint tutorial on constructing functional operating systems at the [Commercial Users of Functional Programming](http://cufp.org) workshop in Tokyo, Japan in September.\n" ]
 | "blog/the-road-to-a-dev-release.md" | "/blog/the-road-to-a-dev-release.md" -> Some ["There's been a crazy stream of activity since the start of the year, but the most important news is that we have a release target for an integrated developer preview of the Mirage stack: a talk at [O'Reilly OSCon](http://www.oscon.com/oscon2013/public/schedule/detail/28956) in July!  Do turn up there and find [Dave Scott](http://dave.recoil.org) and [Anil Madhavapeddy](http://anil.recoil.org) showing off interactive demonstrations.\n\nMeanwhile, another significant announcement has been that Xen is [joining the Linux Foundation](http://www.linuxfoundation.org/news-media/announcements/2013/04/xen-become-linux-foundation-collaborative-project) as a collaborative project.  This is great news for Mirage: as a library operating system, we can operate just as easily under other hypervisors, and even on bare-metal devices such as the [Raspberry Pi](http://raspberrypi.org).  We're very much looking forward to getting the Xen-based developer release done, and interacting with the wider Linux community (and FreeBSD, for that matter, thanks to Gabor Pali's [kFreeBSD](https://github.com/pgj/mirage-kfreebsd) backend).\n\nHere's some other significant news from the past few months:\n\n* [OPAM 1.0 was released](http://www.ocamlpro.com/blog/2013/03/14/opam-1.0.0.html), giving Mirage a solid package manager for handling the many libraries required to glue an application together.  [Vincent Bernardoff](https://github.com/vbmithr) joined the team at Citrix and has been building a Mirage build-frontend called [Mirari](https://github.com/mirage/mirari) to hide much of the system complexity from a user who isn't too familiar with either Xen or OCaml.\n\n* A new group called the [OCaml Labs](http://ocaml.io) has started up in the [Cambridge Computer Laboratory](http://www.cl.cam.ac.uk), and is working on improving the OCaml toolchain and platform.  This gives Mirage a big boost, as we can re-use several of the documentation, build and test improvements in our own releases.  You can read up on the group's activities via the [monthly updates](http://ocaml.io/news), or browse through the various [projects](http://ocaml.io/tasks).  One of the more important projects is the [OCamlot](http://www.cl.cam.ac.uk/projects/ocamllabs/tasks/platform.html#OCamlot) continuous build infrastructure, which will also be testing Mirage kernels as one of the supported backends.\n\n* As we head into release mode, we've started [weekly meetings](/wiki/tag/overview/meetings) to coordinate all the activities.  We're keeping notes as we go along, so you should be able to skim the notes and [mailing list archives](https://lists.cam.ac.uk/pipermail/cl-mirage/) to get a feel for the overall activities.  Anil is maintaining a [release checklist](/wiki/dev-preview-checklist) for the summer developer preview.\n\n* Anil (along with Yaron Minsky and Jason Hickey) is finishing up an O'Reilly book on [Real World OCaml](http://realworldocaml.org), which will be a useful guide to using OCaml for systems and network programming. If you'd like to review an early copy, please get in touch.  The final book is anticipated to be released towards the end of the year, with a [Rough Cut](http://shop.oreilly.com/category/roughcuts.do) at the end of the summer.\n\n* The core system was described in an [ASPLOS 2013](http://anil.recoil.org/papers/2013-asplos-mirage.pdf) paper, which should help you understand the background behind library operating systems. Some of the Mirage libraries are also currently being integrated into the next-generation [Windsor](http://blogs.citrix.com/2012/05/17/introducing-windsor-a-new-xen-based-virtualization-architecture/) release of the Xen Cloud Platform, which means that several of the libraries will be used in production and hence move beyond research-quality code.\n\nIn the next few months, the installation notes and getting started guides will\nall be revamped to match the reality of the new tooling, so expect some flux\nthere.   If you want to take an early try of Mirage beforehand, don't forget to\nhop on the `#mirage` IRC channel on Freenode and ping us with questions\ndire";
"ctly.  We will also be migrating some of the project infrastructure to be fully\nself-hosted on Mirage and Xen, and placing some of the services onto the new [xenproject.org](http://xenproject.org) infrastructure. \n" ]
 | "blog/welcome.md" | "/blog/welcome.md" -> Some ["Welcome to the new self-hosting website for the Mirage project!  As we go about preparing a release for later in the year, this blog will contain technical musings and work-in-progress reports of various bits of the operating system as they mature. Since there's so much to talk about, we decided to start with a blog format, and eventually collect things into a proper document as they stabilise.\n\nFeel free to subscribe to the [Atom](/blog/atom.xml) feed to keep up-to-date with our progress, or just e-mail us or comment on individual posts with any queries.\n" ]
 | "blog/xen-block-devices-with-mirage.md" | "/blog/xen-block-devices-with-mirage.md" -> Some ["[Mirage](http://www.openmirage.org/) is a\n[unikernel](http://anil.recoil.org/papers/2013-asplos-mirage.pdf)\nor \"library operating system\" that allows us to build applications\nwhich can be compiled to very diverse environments: the same code can be linked\nto run as a regular Unix app, relinked to run as a [FreeBSD kernel module](https://github.com/pgj/mirage-kfreebsd),\nand even linked into a\nself-contained kernel which can run on the [Xen\nhypervisor](http://www.xenproject.org/).\n\nMirage has access to an extensive suite of pure OCaml [libraries](https://github.com/mirage),\ncovering everything from Xen [block](https://github.com/mirage/ocaml-xen-block-driver) and [network](https://github.com/mirage/mirage-platform/blob/master/xen/lib/netif.ml) virtual device drivers,\na [TCP/IP stack](https://github.com/mirage/mirage-net), OpenFlow learning switches and controllers, to\nSSH and [HTTP](https://github.com/mirage/ocaml-cohttp) server implementations.\n\nI normally use Mirage to deploy applications as kernels on top of\na [XenServer](http://www.xenserver.org/) hypervisor. I start by\nfirst using the Mirage libraries within a normal Unix userspace\napplication -- where I have access to excellent debugging tools --\nand then finally link my app as a high-performance Xen kernel for\nproduction.\n\nHowever Mirage is great for more than simply building Xen kernels.\nIn this post I'll describe how I've been using Mirage to create\nexperimental virtual disk devices for existing Xen VMs (which may\nthemselves be Linux, *BSD, Windows or even Mirage kernels).\nThe Mirage libraries let me easily\nexperiment with different backend file formats and protocols, all while\nwriting only type-safe OCaml code thats runs in userspace in a normal\nLinux domain 0.\n\n*Disk devices under Xen*\n\nThe protocols used by Xen disk and network devices are designed to\npermit fast and efficient software implementations, avoiding the\ninefficiencies inherent in emulating physical hardware in software.\nThe protocols are based on two primitives:\n\n* *shared memory pages*: used for sharing both data and metadata\n* *event channels*: similar to interrupts, these allow one side to signal the other\n\nIn the disk block protocol, the protocol starts with the client\n(\"frontend\" in Xen jargon) sharing a page with the server (\"backend\").\nThis single page will contain the request/response metadata, arranged\nas a circular buffer or \"ring\". The client (\"frontend\") can then start\nsharing pages containing disk blocks with the backend and pushing request\nstructures to the ring, updating shared pointers as it goes. The client\nwill give the server end a kick via an event channel signal and then both\nends start running simultaneously. There are no locks in the protocol so\nupdates to the shared metadata must be handled carefully, using write\nmemory barriers to ensure consistency.\n\n*Xen disk devices in Mirage*\n\nLike everything else in Mirage, Xen disk devices are implemented as\nlibraries. The ocamlfind library called \"xenctrl\" provides support for\nmanipulating blocks of raw memory pages, \"granting\" access to them to\nother domains and signalling event channels. There are two implementations\nof \"xenctrl\":\n[one that invokes Xen \"hypercalls\" directly](https://github.com/mirage/mirage-platform/tree/master/xen/lib)\n and one which uses the [Xen userspace library libxc](https://github.com/xapi-project/ocaml-xen-lowlevel-libs).\nBoth implementations satisfy a common signature, so it's easy to write\ncode which will work in both userspace and kernelspace.\n\nThe ocamlfind library\n[shared-memory-ring](https://github.com/mirage/shared-memory-ring)\nprovides functions to create and manipulate request/response rings in shared\nmemory as used by the disk and network protocols. This library is a mix of\n99.9% OCaml and 0.1% asm, where the asm is only needed to invoke memory\nbarrier operations to ensure that metadata writes issued by one CPU core\nappear in the same order when viewed from another CPU core.\n\nFinally the ocamlfind library\n[xenblock](https://github.com/mirage/ocaml-xen-block-driver)\nprovides functions to hotplug and ";
"hotunplug disk devices, together with an\nimplementation of the disk block protocol itself.\n\n*Making custom virtual disk servers with Mirage*\n\nLet's experiment with making our own virtual disk server based on\nthe Mirage example program, [xen-disk](https://github.com/mirage/xen-disk).\n\nFirst, install [Xen](http://www.xen.org/), [OCaml](http://www.ocaml.org/)\nand [OPAM](http://opam.ocamlpro.com/). Second initialise your system:\n\n```ocaml\n  opam init\n  eval `opam config env`\n```\n\nAt the time of writing, not all the libraries were released as upstream\nOPAM packages, so it was necessary to add some extra repositories. This\nshould not be necessary after the Mirage developer preview at\n[OSCON 2013](http://www.oscon.com/oscon2013/public/schedule/detail/28956).\n\n```\n  opam remote add mirage-dev git://github.com/mirage/opam-repo-dev\n  opam remote add xapi-dev git://github.com/xapi-project/opam-repo-dev\n```\n\nInstall the unmodified `xen-disk` package, this will ensure all the build\ndependencies are installed:\n\n```\n  opam install xen-disk\n```\nWhen this completes it will have installed a command-line tool called\n`xen-disk`. If you start a VM using your Xen toolstack of choice\n(\"xl create ...\" or \"xe vm-install ...\" or \"virsh create ...\") then you\nshould be able to run:\n\n```\n  xen-disk connect <vmname>\n```\n\nwhich will hotplug a fresh block device into the VM \"<vmname>\" using the\n\"discard\" backend, which returns \"success\" to all read and write requests,\nbut actually throws all data away. Obviously this backend should only be\nused for basic testing!\n\nAssuming that worked ok, clone and build the source for `xen-disk` yourself:\n\n```\n  git clone git://github.com/mirage/xen-disk\n  cd xen-disk\n  make\n```\n\n*Making a custom virtual disk implementation*\n\nThe `xen-disk` program has a set of simple built-in virtual disk implementations.\nEach one satisifies a simple signature, contained in\n[src/storage.mli](https://github.com/mirage/xen-disk/blob/master/src/storage.mli):\n\n```\ntype configuration = {\n  filename: string;      (** path where the data will be stored *)\n  format: string option; (** format of physical data *)\n}\n(** Information needed to \"open\" a disk *)\n\nmodule type S = sig\n  (** A concrete mechanism to access and update a virtual disk. *)\n\n  type t\n  (** An open virtual disk *)\n\n  val open_disk: configuration -> t option Lwt.t\n  (** Given a configuration, attempt to open a virtual disk *)\n\n  val size: t -> int64\n  (** [size t] is the size of the virtual disk in bytes. The actual\n      number of bytes stored on media may be different. *)\n\n  val read: t -> Cstruct.t -> int64 -> int -> unit Lwt.t\n  (** [read t buf offset_sectors len_sectors] copies [len_sectors]\n      sectors beginning at sector [offset_sectors] from [t] into [buf] *)\n\n  val write: t -> Cstruct.t -> int64 -> int -> unit Lwt.t\n  (** [write t buf offset_sectors len_sectors] copies [len_sectors]\n      sectors from [buf] into [t] beginning at sector [offset_sectors]. *)\nend\n```\n\nLet's make a virtual disk implementation which uses an existing disk\nimage file as a \"gold image\", but uses copy-on-write so that no writes\npersist.\nThis is a common configuration in Virtual Desktop Infrastructure deployments\nand is generally handy when you want to test a change quickly, and\nrevert it cleanly afterwards.\n\nA useful Unix technique for file I/O is to \"memory map\" an existing file:\nthis associates the file contents with a range of virtual memory addresses\nso that reading and writing within this address range will actually\nread or write the file contents.\nThe \"mmap\" C function has a number of flags, which can be used to request\n\"copy on write\" behaviour. Reading the\n[OCaml manual Bigarray.map_file](http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.Genarray.html)\nit says:\n\n> If shared is true, all modifications performed on the array are reflected\n> in the file. This requires that fd be opened with write permissions. If\n> shared is false, modifications performed on the array are done in memory\n> only, using copy-on-write of the modified pages; the underlying file is\n> not affected.\n\nSo we should be ab";
"le to make a virtual disk implementation which memory\nmaps the image file and achieves copy-on-write by setting \"shared\" to false.\nFor extra safety we can also open the file read-only.\n\nLuckily there is already an\n[\"mmap\" implementation](https://github.com/mirage/xen-disk/blob/master/src/backend.ml#L63)\nin `xen-disk`; all we need to do is tweak it slightly.\nNote that the `xen-disk` program uses a co-operative threading library called\n[lwt](http://ocsigen.org/lwt/)\nwhich replaces functions from the OCaml standard library which might block\nwith non-blocking variants. In\nparticular `lwt` uses `Lwt_bytes.map_file` as a wrapper for the\n`Bigarray.Array1.map_file` function.\nIn the \"open-disk\" function we simply need to set \"shared\" to \"false\" to\nachieve the behaviour we want i.e.\n\n```\n  let open_disk configuration =\n    let fd = Unix.openfile configuration.filename [ Unix.O_RDONLY ] 0o0 in\n    let stats = Unix.LargeFile.fstat fd in\n    let mmap = Lwt_bytes.map_file ~fd ~shared:false () in\n    Unix.close fd;\n    return (Some (stats.Unix.LargeFile.st_size, Cstruct.of_bigarray mmap))\n```\n\nThe read and write functions can be left as they are:\n\n```\n  let read (_, mmap) buf offset_sectors len_sectors =\n    let offset_sectors = Int64.to_int offset_sectors in\n    let len_bytes = len_sectors * sector_size in\n    let offset_bytes = offset_sectors * sector_size in\n    Cstruct.blit mmap offset_bytes buf 0 len_bytes;\n    return ()\n\n  let write (_, mmap) buf offset_sectors len_sectors =\n    let offset_sectors = Int64.to_int offset_sectors in\n    let offset_bytes = offset_sectors * sector_size in\n    let len_bytes = len_sectors * sector_size in\n    Cstruct.blit buf 0 mmap offset_bytes len_bytes;\n    return () \n```\n\nNow if we rebuild and run something like:\n\n```\n  dd if=/dev/zero of=disk.raw bs=1M seek=1024 count=1\n  losetup /dev/loop0 disk.raw\n  mkfs.ext3 /dev/loop0\n  losetup -d /dev/loop0\n\n  dist/build/xen-disk/xen-disk connect <myvm> --path disk.raw\n```\n\nInside the VM we should be able to do some basic speed testing:\n\n```\n  # dd if=/dev/xvdb of=/dev/null bs=1M iflag=direct count=100\n  100+0 records in\n  100+0 records out\n  104857600 bytes (105 MB) copied, 0.125296 s, 837 MB/s\n```\n\nPlus we should be able to mount the filesystem inside the VM, make changes and\nthen disconnect (send SIGINT to xen-disk by hitting Control+C on your terminal)\nwithout disturbing the underlying disk contents.\n\n*So what else can we do?*\n\nThanks to Mirage it's now really easy to experiment with custom storage types\nfor your existing VMs. If you have a cunning scheme where you want to hash block contents,\nand use the hashes as keys in some distributed datastructure -- go ahead, it's\nall easy to do. If you have ideas for improving the low-level block access protocol\nthen Mirage makes those experiments very easy too.\n\nIf you come up with a cool example with Mirage, then send us a\n[pull request](https://github.com/mirage) or send us an email to the\n[Mirage mailing list](http://www.openmirage.org/about/) -- we'd\nlove to hear about it!\n" ]
 | "blog/xenstore-stub.md" | "/blog/xenstore-stub.md" -> Some ["On all hosts running [Xen](http://www.xen.org/), there is a critical service called [xenstore](http://wiki.xen.org/wiki/XenStore).\nXenstore is used to allow *untrusted* user VMs to communicate with *trusted* system VMs, so that\n\n* virtual disk and network connections can be established\n* performance statistics and OS version information can be shared\n* VMs can be remotely power-cycled, suspended, resumed, snapshotted and migrated.\n\nIf the xenstore service fails then at best the host cannot be controlled (i.e. no VM start or shutdown)\nand at worst VM isolation is compromised since an untrusted VM will be able to gain unauthorised access to disks or networks.\nThis blog post examines how to disaggregate xenstore from the monolithic domain 0, and run it as an independent [stub domain](http://www.cl.cam.ac.uk/~dgm36/publications/2008-murray2008improving.pdf).\n\nRecently in the Xen community, Daniel De Graaf and Alex Zeffertt have added support for\n[xenstore stub domains](http://lists.xen.org/archives/html/xen-devel/2012-01/msg02349.html)\nwhere the xenstore service is run directly as an OS kernel in its own isolated VM. In the world of Xen,\na running VM is a \"domain\" and a \"stub\" implies a single-purpose OS image rather than a general-purpose\nmachine.\nPreviously if something bad happened in \"domain 0\" (the privileged general-purpose OS where xenstore traditionally runs)\nsuch as an out-of-memory event or a performance problem, then the critical xenstore process might become unusable\nor fail altogether. Instead if xenstore is run as a \"stub domain\" then it is immune to such problems in\ndomain 0. In fact, it will even allow us to *reboot* domain 0 in future (along with all other privileged\ndomains) without incurring any VM downtime during the reset!\n\nThe new code in [xen-unstable.hg](http://xenbits.xensource.com/xen-unstable.hg) lays the necessary groundwork\n(Xen and domain 0 kernel changes) and ports the original C xenstored to run as a stub domain.\n\nMeanwhile, thanks to [Vincent Hanquez](http://tab.snarc.org) and [Thomas Gazagnaire](http://gazagnaire.org), we also have an\n[OCaml implementation of xenstore](http://gazagnaire.org/pub/SSGM10.pdf) which, as well as the offering\nmemory-safety, also supports a high-performance transaction engine, necessary for surviving a stressful\n\"VM bootstorm\" event on a large server in the cloud. Vincent and Thomas' code is Linux/POSIX only.\n\nIdeally we would have the best of both worlds:\n\n* a fast, memory-safe xenstored written in OCaml,\n* running directly as a Xen stub domain i.e. as a specialised kernel image without Linux or POSIX\n\nWe can now do both, using Mirage!  If you're saying, \"that sounds great! How do I do that?\" then read on...\n\n*Step 1: remove dependency on POSIX/Linux*\n\nIf you read through the existing OCaml xenstored code, it becomes obvious that the main uses of POSIX APIs are for communication\nwith clients, both Unix sockets and for a special Xen inter-domain shared memory interface. It was a fairly\npainless process to extract the required socket-like IO signature and turn the bulk of the server into\na [functor](http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual004.html). The IO signature ended up looking approximately like:\n\n```\n    type t\n    val read: t -> string -> int -> int -> int Lwt.t\n    val write: t -> string -> int -> int -> unit Lwt.t\n    val destroy: t -> unit Lwt.t\n```\n\nFor now the dependency on [Lwt](http://ocsigen.org/lwt/) is explicit but in future I'll probably make it more abstract so we\ncan use [Core Async](https://ocaml.janestreet.com/?q=node/100) too.\n\n*Step 2: add a Mirage Xen IO implementation*\n\nIn a stub-domain all communication with other domains is via shared memory pages and \"event channels\".\nMirage already contains extensive support for using these primitives, and uses them to create fast\nnetwork and block virtual device drivers. To extend the code to cover the Xenstore stub domain case,\nonly a few tweaks were needed to add the \"server\" side of a xenstore ring communication, in addition\nto the \"client\" side which was already present.\n\nIn Xen, domai";
"ns share memory by a system of explicit \"grants\", where a client (called \"frontend\")\ntells the hypervisor to allow a server (called \"backend\") access to specific memory pages. Mirage\nalready had code to create such grants, all that was missing was a few simple functions to receive\ngrants from other domains.\n\nThese changes are all in the current [mirage-platform](https://github.com/mirage/mirage-platform)\ntree.\n\n*Step 3: add a Mirage Xen \"main\" module and Makefile*\n\nThe Mirage \"main\" module necessary for a stub domain looks pretty similar to the normal Unix\nuserspace case except that it:\n\n* arranges to log messages via the VM console (rather than a file or the network, since a disk or network device cannot be created without a working xenstore, and it's important not to introduce a bootstrap\n     problem here)\n* instantiates the server functor with the shared memory inter-domain IO module.\n\nThe Makefile looks like a regular Makefile, invoking ocamlbuild. The whole lot is built with\n[OASIS](http://oasis.forge.ocamlcore.org/) with a small extension added by [Anil](http://anil.recoil.org/) to set a few options\nrequired for building Xen kernels rather than regular binaries.\n\n... and it all works!\n\nThe code is in two separate repositories:\n* [ocaml-xenstore](https://github.com/djs55/ocaml-xenstore): contains all the generic stuff\n* [ocaml-xenstore-xen](https://github.com/djs55/ocaml-xenstore-xen): contains the unix userspace\n    and xen stub domain IO modules and \"main\" functions\n* (optional) To regenerate the OASIS file, grab the `add-xen` branch from this [OASIS fork](http://github.com/avsm/oasis).\n\n*Example build instructions*\n\nIf you want to try building it yourself, try the following on a modern 64-bit OS. I've tested these\ninstructions on a fresh install of Debian Wheezy.\n\nFirst install OCaml and the usual build tools:\n```\n    apt-get install ocaml build-essential git curl rsync\n```\nThen install the OCamlPro `opam` package manager to simplify the installation of extra packages\n```\n    git clone git://github.com/OCamlPro/opam.git\n    cd opam\n    make\n    make install\n    cd ..\n```\nInitialise OPAM with the default packages:\n```\n    opam --yes init\n    eval `opam config -env`\n```\nAdd the \"mirage\" development package source (this step will not be needed once the package definitions are upstreamed)\n```\n    opam remote -add dev git://github.com/mirage/opam-repo-dev\n```\nSwitch to the special \"mirage\" version of the OCaml compiler\n```\n    opam --yes switch -install 3.12.1+mirage-xen\n    opam --yes switch 3.12.1+mirage-xen\n    eval `opam config -env`\n```\nInstall the generic Xenstore protocol libraries\n```\n    opam --yes install xenstore\n```\nInstall the Mirage development libraries\n```\n    opam --yes install mirage\n```\nIf this fails with \"+ runtime/dietlibc/lib/atof.c:1: sorry, unimplemented: 64-bit mode not compiled in\" it means you need a 64-bit build environment.\nNext, clone the xen stubdom tree\n```\n    git clone git://github.com/djs55/ocaml-xenstore-xen\n```\nBuild the Xen stubdom\n```\n    cd ocaml-xenstore-xen\n    make\n```\nThe binary now lives in `xen/_build/src/server_xen.xen`\n\n*Deploying on a Xen system*\n\nRunning a stub Xenstored is a little tricky because it depends on the latest and\ngreatest Xen and Linux PVops kernel. In the future it'll become much easier (and probably\nthe default) but for now you need the following:\n\n* xen-4.2 with XSM (Xen Security Modules) turned on\n* A XSM/FLASK policy which allows the stubdom to call the \"domctl getdomaininfo\". For the moment it's safe to skip this step with the caveat that xenstored will leak connections when domains die.\n* a Xen-4.2-compatible toolstack (either the bundled xl/libxl or xapi with [some patches](http://github.com/djs55/xen-api/tree/xen-4.2))\n* Linux-3.5 PVops domain 0 kernel\n* the domain builder binary `init-xenstore-domain` from `xen-4.2/tools/xenstore`.\n\nTo turn the stub xenstored on, you need to edit whichever `init.d` script is currently starting xenstore and modify it to call\n```\n    init-xenstore-domain /path/to/server_xen.xen 256 flask_label\n```\n" ]
 | "docs.md" | "/docs.md" -> Some ["!! Documentation\n\nMirage is still under heavy development, and so there is no detailed documentation available.  However, if you are keen to hack, you can read the [INSTALL](http://github.com/avsm/mirage/blob/master/INSTALL) file and give it a shot.\n\nFeedback and questions are always welcome via e-mail to `cl-mirage@lists.cam.ac.uk` or catch us on `#mirage` on FreeNode IRC.\n\nThe best way to wait for a release is to [watch](http://github.com/avsm/mirage/toggle_watch) the project on [GitHub](http://github.com/avsm/mirage).\n" ]
 | "iconize.css.inc" | "/iconize.css.inc" -> Some ["/* Iconize 0.5 */\n\n/* extensions */\n\na[href^='/'] {\n\tpadding: 5px 20px 0px 0;\n\tbackground: transparent url(/icons/icon_external.gif) no-repeat center right;\n}\n\na[href$='.doc'], a[href$='.rtf'] {\n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_doc.gif) no-repeat center right;\n}\n\na[href$='.txt'] {\n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_txt.gif) no-repeat center right;\n}\n\na[href$='.xls'] {\n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_xls.gif) no-repeat center right;\n}\n\na[href$='.rss'], a[href$='.atom'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_feed.gif) no-repeat center right;\n}\n\na[href$='.opml'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_opml.gif) no-repeat center right;\n}\n\na[href$='.phps'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_phps.gif) no-repeat center right;\n}\n\na[href$='.phps'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_phps.gif) no-repeat center right;\n}\n\na[href$='.torrent'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_torrent.gif) no-repeat center right;\n}\n\na[href$='.vcard'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_vcard.gif) no-repeat center right;\n}\n\na[href$='.exe'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_exe.gif) no-repeat center right;\n}\n\na[href$='.dmg'], a[href$='.app'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_dmg.gif) no-repeat center right;\n}\n\na[href$='.pps'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_pps.gif) no-repeat center right;\n}\n\na[href$='.pdf'] { \n\tpadding: 5px 20px 0px 0;\n\tbackground: transparent url(/icons/icon_pdf.gif) no-repeat center right;\n}\n\na[href$='.xpi'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_plugin.gif) no-repeat center right;\n}\n\na[href$='.fla'], a[href$='.swf'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_flash.gif) no-repeat center right;\n}\n\na[href$='.zip'], a[href$='.rar'], a[href$='.gzip'], a[href$='.bzip'], a[href$='.ace'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_archive.gif) no-repeat center right;\n}\n\na[href$='.ical'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_ical.gif) no-repeat center right;\n}\n\na[href$='.css'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_css.gif) no-repeat center right;\n}\n\na[href$='.ttf'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_ttf.gif) no-repeat center right;\n}\n\na[href$='.jpg'], a[href$='.gif'], a[href$='.png'], a[href$='.bmp'], a[href$='.jpeg'], a[href$='.svg'], a[href$='.eps'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_pic.gif) no-repeat center right;\n}\n\na[href$='.mov'], a[href$='.wmv'], a[href$='.mp4'], a[href$='.avi'], a[href$='.mpg'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_film.gif) no-repeat center right;\n}\n\na[href$='.mp3'], a[href$='.wav'], a[href$='.ogg'], a[href$='.wma'], a[href$='.m4a'] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_music.gif) no-repeat center right;\n}\n\n/* messenger */\na[href ^=\"aim:\"] {\n\tpadding: 5px 18px 0px 0;\n    background: transparent url(/icons/icon_aim.gif) no-repeat center right;\n}\n\na[href ^=\"msnim:\"] {\n\tpadding: 5px 18px 0px 0;\n    background: transparent url(/icons/icon_msn.gif) no-repeat center right;\n}\n\na[href ^=\"xmpp:\"] {\n\tpadding: 5px 18px 0px 0;\n    background: transparent url(/icons/icon_jabber.gif) no-repeat center right;\n}\n\na[href *=\"icq.com\"] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_icq.gif) no-repeat center right;\n}\n\na[href *=\"edit.yahoo.com/config/send_webmesg?\"] { \n\tpadding: 5px 18px 0px 0;\n\tbackground: transparent url(/icons/icon_yim.gif) no-repeat center right;\n}\n\na[href ^=\"callto:\"] {\n\tpadding: 5px 18px 0px 0;\n    background: transparent url(/icons/icon_call.gif) no-repeat center right;\n}\n\na[href ^=\"skype:\"] {\n\tpadding: 5px 18p";
"x 0px 0;\n    background: transparent url(/icons/icon_skype.gif) no-repeat center right;\n}\n\na[href ^=\"gg:\"] {\n\tpadding: 5px 18px 0px 0;\n    background: transparent url(/icons/icon_gadugadu.gif) no-repeat center right;\n}\n\n/* email */\na[href ^=\"mailto:\"] {\n\tpadding: 5px 18px 0px 0;\n    background: transparent url(/icons/icon_mailto.gif) no-repeat center right;\n}\n\n/* use this class to make sure that images won't get iconized */\n\n.noIcon {\n\tpadding-right: 0px !important;\n\tbackground: none !important;\n}\n\n" ]
 | "intro-r.html" | "/intro-r.html" -> Some ["<style>\n.codehilite .hll { background-color: #404040 }\n.hll { padding: 2px; margin-top: 10px; }\n.codehilite .c { color: #999999; font-style: italic } /* Comment */\n.codehilite .err { color: #a61717; background-color: #e3d2d2 } /* Error */\n.codehilite .g { color: #d0d0d0 } /* Generic */\n.codehilite .k { color: #6ab825; font-weight: bold } /* Keyword */\n.codehilite .l { color: #d0d0d0 } /* Literal */\n.codehilite .n { color: #d0d0d0 } /* Name */\n.codehilite .o { color: #d0d0d0 } /* Operator */\n.codehilite .x { color: #d0d0d0 } /* Other */\n.codehilite .p { color: #d0d0d0 } /* Punctuation */\n.codehilite .cm { color: #999999; font-style: italic } /* Comment.Multiline */\n.codehilite .cp { color: #cd2828; font-weight: bold } /* Comment.Preproc */\n.codehilite .c1 { color: #999999; font-style: italic } /* Comment.Single */\n.codehilite .cs { color: #e50808; font-weight: bold; background-color: #520000 } /* Comment.Special */\n.codehilite .gd { color: #d22323 } /* Generic.Deleted */\n.codehilite .ge { color: #d0d0d0; font-style: italic } /* Generic.Emph */\n.codehilite .gr { color: #d22323 } /* Generic.Error */\n.codehilite .gh { color: #ffffff; font-weight: bold } /* Generic.Heading */\n.codehilite .gi { color: #589819 } /* Generic.Inserted */\n.codehilite .go { color: #cccccc } /* Generic.Output */\n.codehilite .gp { color: #aaaaaa } /* Generic.Prompt */\n.codehilite .gs { color: #d0d0d0; font-weight: bold } /* Generic.Strong */\n.codehilite .gu { color: #ffffff; text-decoration: underline } /* Generic.Subheading */\n.codehilite .gt { color: #d22323 } /* Generic.Traceback */\n.codehilite .kc { color: #6ab825; font-weight: bold } /* Keyword.Constant */\n.codehilite .kd { color: #6ab825; font-weight: bold } /* Keyword.Declaration */\n.codehilite .kn { color: #6ab825; font-weight: bold } /* Keyword.Namespace */\n.codehilite .kp { color: #6ab825 } /* Keyword.Pseudo */\n.codehilite .kr { color: #6ab825; font-weight: bold } /* Keyword.Reserved */\n.codehilite .kt { color: #6ab825; font-weight: bold } /* Keyword.Type */\n.codehilite .ld { color: #d0d0d0 } /* Literal.Date */\n.codehilite .m { color: #3677a9 } /* Literal.Number */\n.codehilite .s { color: #ed9d13 } /* Literal.String */\n.codehilite .na { color: #bbbbbb } /* Name.Attribute */\n.codehilite .nb { color: #24909d } /* Name.Builtin */\n.codehilite .nc { color: #447fcf; text-decoration: underline } /* Name.Class */\n.codehilite .no { color: #40ffff } /* Name.Constant */\n.codehilite .nd { color: #ffa500 } /* Name.Decorator */\n.codehilite .ni { color: #d0d0d0 } /* Name.Entity */\n.codehilite .ne { color: #bbbbbb } /* Name.Exception */\n.codehilite .nf { color: #447fcf } /* Name.Function */\n.codehilite .nl { color: #d0d0d0 } /* Name.Label */\n.codehilite .nn { color: #447fcf; text-decoration: underline } /* Name.Namespace */\n.codehilite .nx { color: #d0d0d0 } /* Name.Other */\n.codehilite .py { color: #d0d0d0 } /* Name.Property */\n.codehilite .nt { color: #6ab825; font-weight: bold } /* Name.Tag */\n.codehilite .nv { color: #40ffff } /* Name.Variable */\n.codehilite .ow { color: #6ab825; font-weight: bold } /* Operator.Word */\n.codehilite .w { color: #666666 } /* Text.Whitespace */\n.codehilite .mf { color: #3677a9 } /* Literal.Number.Float */\n.codehilite .mh { color: #3677a9 } /* Literal.Number.Hex */\n.codehilite .mi { color: #3677a9 } /* Literal.Number.Integer */\n.codehilite .mo { color: #3677a9 } /* Literal.Number.Oct */\n.codehilite .sb { color: #ed9d13 } /* Literal.String.Backtick */\n.codehilite .sc { color: #ed9d13 } /* Literal.String.Char */\n.codehilite .sd { color: #ed9d13 } /* Literal.String.Doc */\n.codehilite .s2 { color: #ed9d13 } /* Literal.String.Double */\n.codehilite .se { color: #ed9d13 } /* Literal.String.Escape */\n.codehilite .sh { color: #ed9d13 } /* Literal.String.Heredoc */\n.codehilite .si { color: #ed9d13 } /* Literal.String.Interpol */\n.codehilite .sx { color: #ffa500 } /* Literal.String.Other */\n.codehilite .sr { color: #ed9d13 } /* Literal.String.Regex */\n.codehilite .s1 { color: #ed9d13 } /* Literal.String.Single */\n.codehilite .ss { color: #ed9d13 } /* Literal.String.Symbol */\n.codehilit";
"e .bp { color: #24909d } /* Name.Builtin.Pseudo */\n.codehilite .vc { color: #40ffff } /* Name.Variable.Class */\n.codehilite .vg { color: #40ffff } /* Name.Variable.Global */\n.codehilite .vi { color: #40ffff } /* Name.Variable.Instance */\n.codehilite .il { color: #3677a9 } /* Literal.Number.Integer.Long */\n</style>\n\n<div class=\"codehilite\">\n<div class=\"hll\"><pre><span class=\"k\">let</span> <span class=\"n\">echo</span> <span class=\"bp\">()</span> <span class=\"o\">=</span>\n  <span class=\"n\">lwt</span> <span class=\"n\">mgr</span><span class=\"o\">,</span> <span class=\"n\">mgr_t</span> <span class=\"o\">=</span> <span class=\"nn\">Manager</span><span class=\"p\">.</span><span class=\"n\">create</span> <span class=\"bp\">()</span> <span class=\"k\">in</span>\n  <span class=\"k\">let</span> <span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"nc\">None</span><span class=\"o\">,</span> <span class=\"mi\">8081</span> <span class=\"k\">in</span> \n  <span class=\"nn\">Flow</span><span class=\"p\">.</span><span class=\"n\">listen</span> <span class=\"n\">mgr</span> <span class=\"o\">(`</span><span class=\"nc\">TCPv4</span> <span class=\"o\">(</span><span class=\"n\">src</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">addr</span><span class=\"o\">,</span> <span class=\"n\">port</span><span class=\"o\">)</span> <span class=\"n\">t</span> <span class=\"o\">-&gt;</span>\n       <span class=\"nn\">Console</span><span class=\"p\">.</span><span class=\"n\">log</span> <span class=\"s2\">&quot;From %s:%d&quot;</span> <span class=\"o\">(</span><span class=\"n\">ipv4_addr_to_string</span> <span class=\"n\">addr</span><span class=\"o\">)</span> <span class=\"n\">port</span><span class=\"o\">;</span>\n       <span class=\"k\">let</span> <span class=\"k\">rec</span> <span class=\"n\">echo</span> <span class=\"bp\">()</span> <span class=\"o\">=</span>\n         <span class=\"n\">lwt</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"nn\">Flow</span><span class=\"p\">.</span><span class=\"n\">read</span> <span class=\"n\">t</span> <span class=\"k\">in</span>\n         <span class=\"k\">match</span> <span class=\"n\">res</span> <span class=\"k\">with</span>\n         <span class=\"o\">|</span><span class=\"nc\">None</span> <span class=\"o\">-&gt;</span>\n            <span class=\"nn\">Console</span><span class=\"p\">.</span><span class=\"n\">log</span> <span class=\"s2\">&quot;Connection closed&quot;</span><span class=\"o\">;</span>\n            <span class=\"n\">return</span> <span class=\"bp\">()</span>\n         <span class=\"o\">|</span><span class=\"nc\">Some</span> <span class=\"n\">data</span> <span class=\"o\">-&gt;</span>\n            <span class=\"nn\">Flow</span><span class=\"p\">.</span><span class=\"n\">write</span> <span class=\"n\">t</span> <span class=\"n\">data</span> <span class=\"o\">&gt;&gt;=</span> <span class=\"n\">echo</span>\n       <span class=\"k\">in</span>\n       <span class=\"n\">echo</span> <span class=\"bp\">()</span>\n    <span class=\"o\">)</span>\n  <span class=\"o\">))</span>\n</pre></div>\n</div>\n" ]
 | "intro.md" | "/intro.md" -> Some ["Mirage is an [exokernel](http://en.wikipedia.org/wiki/Exokernel) for constructing secure, high-performance network applications across a variety of cloud computing and mobile platforms.  Code can be developed on a normal OS such as Linux or MacOS X, and then compiled into a fully-standalone, specialised microkernel that runs under the [Xen](http://xen.org/) hypervisor.  Since Xen powers most public [cloud computing](http://en.wikipedia.org/Cloud_computing) infrastructure such as [Amazon EC2](http://aws.amazon.com), this lets your servers run more cheaply, securely and finer control than with a full software stack.\n\nMirage is based around the [OCaml](http://caml.inria.fr/) language, with syntax extensions and libraries which provide networking, storage and concurrency support that are easy to use during development, and map directly into operating system constructs when being compiled for production deployment. The framework is fully event-driven, with no support for preemptive threading.\n\nMirage is still in *pre-alpha stage*, but the infrastructure you see here is self-hosting. Check out the [wiki](/wiki) for an [installation](/wiki/install) guide, compile your [hello world microkernel](/wiki/hello-world), get started with the [public cloud](/wiki/xen-boot), or watch the [talk](/wiki/talks) and read the [papers](/wiki/papers).\n" ]
 | "main.html" | "/main.html" -> Some ["<html>\n\n<head>\n  <title>openmirage :: $TITLE$</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/index.css\"/>\n  <script type=\"text/javascript\">\n    var _gaq = _gaq || [];\n    _gaq.push(['_setAccount', 'UA-19610168-1']);\n    _gaq.push(['_trackPageview']);\n\n    (function() {\n      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;\n      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';\n      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);\n    })();\n  </script> \n  $EXTRA_HEADER$\n</head>\n\n<body>\n  <div id=\"wrapper\">\n    <div id=\"header\">\n      <div id=\"header_logo\">\n        <a id=\"logo\" href=\"/\"><img src=\"/graphics/mirage-logo.png\" alt=\"Logo\" /></a>\n      </div>\n      <div id=\"info_bar\">\n        <div id=\"linkbar\">\n          <ul>\n            $BAR$\n          </ul>\n        </div>\n      </div>\n    </div>\n  \n    <div id=\"content\">\n      $CONTENT$\n      <div class=\"clear_div\"></div><!-- Clears above floated columns -->\n    </div>\n\n   <script type=\"text/javascript\">\n    var disqus_shortname = 'openmirage';\n    (function () {\n      var s = document.createElement('script'); s.async = true;\n      s.src = 'http://disqus.com/forums/openmirage/count.js';\n      (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);\n    })();\n  </script>\n\n  </div>\n  <div id=\"footer\">\n    <h4>(c) 2009-2011 Anil Madhavapeddy</h4>\n    <ul>\n      $BAR$\n    </ul>\n  </div>\n\n</body>\n\n</html>\n" ]
 | "wiki/cow.md" | "/wiki/cow.md" -> Some ["Writing web-applications requires a lot of skills: [HTML](http://en.wikipedia.org/wiki/HTML),\n[CSS](http://en.wikipedia.org/wiki/Cascading_Style_Sheets), [XML](http://en.wikipedia.org/wiki/XML),\n[JSON](http://en.wikipedia.org/wiki/JSON), [Markdown](http://en.wikipedia.org/wiki/Markdown),\n[JavaScript](http://en.wikipedia.org/wiki/JavaScript) and [SQL](http://en.wikipedia.org/wiki/SQL), to name but a few!\nYou also need to master the art of plumbing: translating concepts across languages is tedious and\nerror-prone.\n\nThis post describes a library we developed to help solve these problems, dubbed\n[Cow](http://www.github.com/samoht/mirage/lib/cow) (for __Caml On the Web__).\nCow generalises our previous post about [HTCaML](/wiki/htcaml) by:\n\n* extending standard OCaml syntax with embedded web [DSLs](http://en.wikipedia.org/wiki/Domain-specific_language). It has a quotation mechanism which parses HTML, CSS or XML to OCaml, and also anti-quotations that form a template mechanism.\n\n* using type-driven code generation to generate markup directly from OCaml type declarations. It is possible to mix hand-written and generated code to deal with special-cases.\n\nMost of the work is done at pre-processing time, so there is no runtime costs and the generated OCaml code can be manually inspected if desired.\n\n<img src=\"/graphics/cow-schema.png\" alt=\"schema\" width=\"50%\"/>\n\n!!!!Quotations and anti-quotations\n\nCamlp4 quotations are an easy way to manipulate the OCaml syntax tree and embed custom syntax.\nQuotations are named, and are enclosed between `<:name< ... >>`.\nEach name has a corresponding parser that handles the contents between the angle brackets.\nCode can still be embedded via __anti-quotations__ that escape back to the\nOCaml world using `$...$` inside quotations.\nLets show an example of this via a built-in `camlp4` quotation, `<:expr< ... >>`, which translates OCaml syntax into its corresponding AST fragment (as the compiler itself does):\n\n```\nlet x = <:expr< Random.int 10 >>\nlet e = <:expr< 1 + $x$ >>\nlet t = <:ctyp< int list >>\n```\n\ninstead of the more tedious:\n\n```\nlet x =\n  Ast.ExApp (_loc,\n    (Ast.ExId (_loc,\n      (Ast.IdAcc (_loc,\n        (Ast.IdUid (_loc, \"Random\")),\n        (Ast.IdLid (_loc, \"int\")))))),\n    (Ast.ExInt (_loc, \"10\")))\n\nlet e =\n  Ast.ExApp (_loc,\n    (Ast.ExApp (_loc,\n      (Ast.ExId (_loc,\n        (Ast.IdLid (_loc, \"+\")))),\n          (Ast.ExInt (_loc, \"1\")))),\n    x)\n\nlet t =\n  Ast.TyApp (_loc,\n    (Ast.TyId (_loc,\n      (Ast.IdLid (_loc, \"int\")))),\n        (Ast.TyId (_loc,\n          (Ast.IdLid (_loc, \"list\")))))\n```\n\nIn Cow, each web syntax registers its own quotation, within which a user\ncan write any valid code of the embedded language, and use anti-quotations to call\nback into OCaml code. Values produced by anti-quotations should be of\nthe same type as the quotations they are embedded in.\nBelow is an example of an HTML quotation:\n\n```\nlet world : Html.t = <:html< \"World\" >>\nlet html = <:html< <h1>Hello $world$!</h1> >>\n```\n\nHere, quotations will be expanded to values of type `Html.t` (the type annotation is provided\nfor clarity, and is usually inferred automatically).\n\nIt is possible to give hints to the quotation expander about the expected type of a given anti-quotation.\nThe hints appear as a prefix of the anti-quotations; the usual\nones are `$str:...$` for strings, `$int:...$` and `$flo:...$` for numerals and `$list:...$` for lists.\nThe preceding example could thus be written as:\n\n```\nlet world = \"world\"\nlet html = <:html< <h1>Hello $str:world$!</h1> >>\n```\n\nIt is possible to use different quotations in the same file:\n\n```\nlet css = : Css.t = <:css<\n  h1 $tag$ {\n    font-style: bold;\n    $Css.rounded_corners$;\n  } >>\n\nlet xml : Xml.t =\n  <:xml< <book><title>foo</title></book> >>\n\nlet js : Javascript.t =\n  <:js< document.write(\"This is my first JavaScript!\"); >>\n\nlet js2 : Javascript.t =\n  <:camlscript< List.iter print_int [1;2;3] >>\n```\n\nThe `<:css< >>`, `<:xml< >>` and `<:html< >>` quotations are present in Mirage today, and the `<:js< >>` and `<:camlscript< >>` quotations will be integrated soon.  `js` uses J";
"ake Donham's [ocamljs](https://github.com/jaked/ocamljs) and an early prototype of `camlscript` is [available](https://github.com/samoht/camlscript) on Github.\n\n!!!Type-driven Code Generation\n\nIn ML, we rely on the type-inferrer/checker as much as possible. Types are usually specified first, followed by the functions which manipulate values of those types.\nThe static typing in OCaml means that type information is discarded at run-time, making it cheap to encode as much of the problem in the types as possible. \n\n* the language of types is expressive (product types, sum types, objects, type variables, etc.)\n* the language of types is concise.\n* all the complex types are inferred.\n\nSo the idea in Cow is to use normal OCaml types in programs and __automatically__ generate web fragments\nfrom them. We previous experimented with a similar approach to [persist ML values](http://gazagnaire.org/pub/GM10.pdf) via a SQL-based Object Relational Mapper.\n\nLet's try to create a web-page containing some [tweets](http://twitter.com) using quotations only.\nFirst of all, let's define the types:\n\n```\ntype user = {\n  id_str      : string;\n  screen_name : string;\n}\n\ntype status = {\n  id   : int;\n  user : user;\n  text : string;\n}\n```\n\nThen let us reason by induction on the types.\n\nFor user:\n\n```\nlet html_of_user u = <:html<\n  <div class=id_str>$str:u.id_str$</div>\n  <div class=screen_name>$str:u.screen_name$</div>\n>>\n\nlet css_of_user = <:css<\n  .id_str { display: none; }\n  .screen_name { display: inline; color: blue; }\n>>\n```\n\nFor status updates:\n\n```\nlet html_of_status s = <:html\n  <div class=id>$int:s.id$</div>\n  <div class=user>$html_of_user s.u$</div>\n  <div class=text>$str:s.text$</div>\n>>\n\nlet css_of_status = <:css<\n  .id { display: none; }\n  .user $css_of_user$;\n  .text { color: grey; }\n>>\n```\n\nThe coding style is nice because we can write HTML and CSS fragments\nclose to where the type is defined.  However, some of the code\nwritten to generate the HTML fragments is quite repetitive.\nFortunately, Cow can generate default code based on annotated type\ndefinitions. The `html_of_user` and `html_of_status` functions above\ncan be automatically generated by adding `with html` to type\ndefinitions, as shown below:\n\n```\ntype user = {\n  id_str      : string;\n  screen_name : string;\n} with html\n\ntype status = {\n  id   : int;\n  user : user;\n  text : string;\n} with html\n```\n\nThe `css_of_*` values are very application specific and so there is no support for\nauto-generating this. However, it may be possible to generate a CSS validator to\ncheck that the CSS fragment generated for a type does not define classes which are not defined\nin the type.\n\n!!!!More code generation\n\nThe next step is to use the Twitter API to actually read tweets? The API uses JSON, and most of the\nexisting implementations use a JSON un-marshaler to association lists, and then build an ML object out of it\n(such as [ocamltter](https://github.com/yoshihiro503/ocamltter) or [ocaml-twitterstream](https://github.com/mariusaeriksen/ocaml-twitterstream)).\nIn Cow, we instead rely on code-generation like [this](https://github.com/avsm/mirage/blob/master/lib/cow/lib/twitter.ml):\n\n```\ntype user = {\n  id_str      : string;\n  screen_name : string;\n} with json\n\ntype status = {\n  id   : int;\n  user : user;\n  text : string;\n} with json\n```\n\nThe `type t = [..] with json` will __automatically__ generate JSON marshal and unmarshalling functions:\n\n```\nval t_of_user : t -> Json.t\nval user_of_t : Json.t -> t\n```\n\nIt is possible to combine multiple code generators by separating the annotations with a comma, e.g.\n`type t = [..] with html,json`. It is thus possible to use Cow with the [ORM](https://www.github.com/mirage/orm)\nlibrary to persist typed values with SQLite (this is not integrated into Mirage just yet, but will be soon).\n\n!!!!Mixing generated and hand-written code\n\nManual and automatic code generation can also be easily mixed. The code which is auto-generated simply calls\ninto other functions with predictable names (e.g. `html_of_foo`). Since OCaml is lexically scoped, the user simply\nhas to override this func";
"tion by manually defining it, and it will be used in place of the auto-generated fragment.\n\nA good example of mixing automatically generated and manually written code is the\n[bindings](http://www.github.com/avsm/blob/master/mirage/lib/cow/lib/atom.ml) to\n[Atom](http://en.wikipedia.org/wiki/Atom_%28standard%29) for blog syndication.\nThis has some very specific attribute names in the content which cannot be auto-generated:\n\n```\ntype meta = [..] with xml\n\ntype content = Xml.t\n\nlet xml_of_content c = <:xml<\n  <content type=\"xhtml\">\n    <xhtml:div xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\n      $c$\n    </xhtml:div>\n  </content>\n>>\n\ntype entry = {\n  entry   : meta;\n  summary : string option;\n  content : content;\n} with xml\n\ntype feed = {\n  feed    : meta;\n  entries : entry list;\n}\n\nlet xml_of_feed f = <:xml<\n  <feed xmlns=\"http://www.w3.org/2005/Atom\">\n    $xml_of_meta f.feed$\n    $list:List.map xml_of_entry f.entries$\n  </feed>\n>>\n```\n\nThis has been a quick overview of the Cow syntax handlers in Mirage. They are still a work-in-progress, but this website is built using them. Thanks to Jake Donham and Nicolas Pouillard for their excellent [meta-programming tutorial](https://github.com/jaked/cufp-metaprogramming-tutorial/tree/master/solutions/ocaml/json_quot) at [CUFP 2010](http://cufp.org/conference/sessions/2010/camlp4-and-template-haskell) that kicked off this work.\n" ]
 | "wiki/delimcc-vs-lwt.md" | "/wiki/delimcc-vs-lwt.md" -> Some ["Mirage is a fully event-driven system, with no support for conventional [preemptive threads](http://en.wikipedia.org/wiki/POSIX_Threads).  Instead, programs are woken by events such as incoming network packets, and event callbacks execute until they themselves need to block (due to I/O or timers) or complete their task.\n\nEvent-driven systems are simple to implement, scalable to lots of network clients, and very hip due to frameworks like [node.js](http://nodejs.org). However, programming event callbacks directly leads to the control logic being scattered across many small functions, and so we need some abstractions to hide the interruptions of registering and waiting for an event to trigger.\n\nOCaml has the excellent [Lwt](http://ocsigen.org) threading library that utilises a monadic approach to solving this.\nConsider this simplified signature:\n\n```\n  val return : 'a -> 'a Lwt.t \n  val bind : 'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t\n  val run : 'a Lwt.t -> 'a\n```\n\nThreads have the type `'a Lwt.t`, which means that the thread will have a result of type `'a` when it finishes.\nThe `return` function is the simplest way to construct such a thread from an OCaml value.\n\nIf we then wish to use the value of thread, we must compose a function that will be called in the future when the thread completes. This is what the `bind` function above is for. For example, assume we have a function that will let us sleep for some time:\n\n```\n  val sleep: int -> unit Lwt.t\n```\n\nWe can now use the `bind` function to do something after the sleep is complete:\n\n```\n  let x = sleep 5 in\n  let y = bind x (fun () -> print_endline \"awake!\") in\n  run y\n```\n\n`x` has the type `unit Lwt.t`, and the closure passed to `bind` will eventually be called with `unit` when the sleep finishes. Note that we also need a function to actually begin evaluating an Lwt thread, which is the `run` function.\n\n!!Concerns\n\nMirage currently uses Lwt extensively, and we have been very happy with using it to build a network stack. However, I was surprised to hear a lot of debate at the [2011 OCaml Users Group](http://anil.recoil.org/2011/04/15/ocaml-users-group.html) meeting that Lwt is not to everyone's tastes. There are a few issues:\n\n* The monadic style means that existing code will not just work. Any code that might block must be adapted to use `return` and `bind`, which makes integrating third-party code problematic.\n\n* More concerningly, any potential blocking points require the allocation of a closure. This allocation is very cheap in OCaml, but is still not free. Jun Furuse notes that combinator-based systems are slower during the development of his [Planck parser](http://camlspotter.blogspot.com/2011/05/planck-small-parser-combinator-library.html).\n\nLwt addresses the first problem via a comprehensive [syntax extension](http://ocsigen.org/lwt/2.3.0/api/Pa_lwt) which provides Lwt equivalents for many common operations. For example, the above example with sleep can be written as:\n\n```\n  lwt x = sleep 5 in\n  print_endline \"awake\"\n```\n\nThe `lwt` keyword indicates the result of the expression should be passed through `bind`, and this makes it possible to write code that looks more OCaml-like. There are also other keywords like `for_lwt` and `match_lwt` that similarly help with common control flow constructs.\n\n!!Fibers\n\nAfter the meeting, I did get thinking about using alternatives to Lwt in Mirage. One exciting option is the [delimcc](http://okmij.org/ftp/continuations/implementations.html) library which implements [delimited continuations](http://en.wikipedia.org/wiki/Delimited_continuation) for OCaml.  These can be used to implement restartable exceptions: a program can raise an exception which can be invoked to resume the execution as if the exception had never happened. \nDelimcc can be combined with Lwt very elegantly, and Jake Donham did just this with the [Lwt_fiber](http://ambassadortothecomputers.blogspot.com/2010/08/mixing-monadic-and-direct-style-code.html) library. His post also has a detailed explanation of how `delimcc` works.\n\nThe interface for fibers is also simple:\n\n```\n";
"  val start: (unit -> 'a) -> 'a Lwt.t\n  val await : 'a Lwt.t -> 'a\n```\n\nA fiber can be launched with `start`, and during its execution can block on another thread with `await`.  When it does block, a restartable exception saves the program stack back until the point that `start` was called, and it will be resumed when the thread it blocked on completes.\n\n!!Benchmarks\n\nI put together a few microbenchmarks to try out the performance of Lwt threads versus fibers. The fiber test looks like this:\n\n```\n  module Fiber = struct\n    let basic fn yields =\n      for i = 1 to 15000 do\n        for x = 1 to yields do\n          Lwt_fiber.await (fn ())\n        done\n      done\n\n    let run fn yields =\n      Lwt_fiber.start (fun () -> basic fn yields)\n  end\n```\n\nWe invoke the run function with two arguments: a thread to use for blocking and the number of times we should yield serially (so we can confirm that an increasing number of yields scales linearly).  The Lwt version is pretty similar:\n\n```\n  module LWT = struct\n    let basic fn yields =\n      for_lwt i = 1 to 15000 do\n        for_lwt x = 1 to yields do\n          fn ()\n        done\n      done\n  \n    let run = basic\n  end\n```\n\nWe do not need to do anything special to launch a thread since we are already in the Lwt main loop, and the syntax extension makes the `for` loops look like the Fiber example above.\n\nThe choice of blocking function is important. The first test runs using a fast `Lwt.return ()` that returns immediately:\n\n<img src=\"http://chart.apis.google.com/chart?cht=lxy&amp;chs=600x250&amp;chtt=Direct%20non-blocking%20overhead&amp;chco=FF0000,00FF00,0000FF,FFAA00,AA00FF,00FFFF&amp;chxt=x,x,y,y&amp;chxl=1:|number-of-yields|3:|seconds&amp;chds=a&amp;chg=10,10,1,5&amp;chd=t:50,100,200,300,400,600,800,1000|0.101,0.195,0.388,0.581,0.775,1.157,1.548,1.926|50,100,200,300,400,600,800,1000|0.095,0.188,0.371,0.553,0.737,1.104,1.469,1.836&amp;chdl=delimcc-basic-quick|lwt-basic-quick&amp;chdlp=t&amp;chls=2|2\" />\n\nThe x-axis on the above graph represents the number of yields in each loop. Both `Lwt_fiber` and pure `Lwt` optimise the case where a thread returns immediately, and so this graph simply tells us that the fast path is working (which is nice!). The next test replaces the blocking function with two alternatives that force the thread to yield:\n\n<img src=\"http://chart.apis.google.com/chart?cht=lxy&amp;chs=600x250&amp;chtt=Direct%20blocking%20overhead&amp;chco=FF0000,00FF00,0000FF,FFAA00,AA00FF,00FFFF&amp;chxt=x,x,y,y&amp;chxl=1:|number-of-yields|3:|seconds&amp;chds=a&amp;chg=10,10,1,5&amp;chd=t:50,100,200,300,400,600,800,1000|2.601,5.204,10.401,15.611,20.783,31.221,41.606,52.016|50,100,200,300,400,600,800,1000|1.270,2.539,5.089,7.626,10.188,15.338,20.385,25.473|50,100,200,300,400,600,800,1000|4.011,8.013,15.973,23.995,32.075,47.940,63.966,79.914|50,100,200,300,400,600,800,1000|2.433,4.861,9.692,14.543,19.702,29.579,39.458,49.260&amp;chdl=lwt-basic-slow|lwt-basic-medium|delimcc-basic-slow|delimcc-basic-medium&amp;chdlp=t&amp;chls=2|2|2|2\"/>\n\nThere are two blocking functions used in the graph above:\n\n* the \"slow\" version is `Lwt_unix.sleep 0.0` which forces the registration of a timeout.\n* the \"medium\" version is `Lwt.pause ()` which causes the thread to pause and drop into the thread scheduler. In the case of `Lwt_fiber`, this causes an exception to be raised so we can benchmark the cost of using a delimited continuation.\n\nInterestingly, using a fiber is slower than normal Lwt here, even though our callstack is not very deep.  I would have hoped that fibers would be significantly cheaper with a small callstack, as the amount of backtracking should be quite low.  Lets confirm that fibers do in fact slow down as the size of the callstack increases via this test:\n\n```\n  module Fiber = struct\n    let recurse fn depth =\n      let rec sum n = \n        Lwt_fiber.await (fn ());\n        match n with\n        |0 -> 0\n        |n -> n + (sum (n-1)) \n      in\n      for i = 1 to 15000 do\n        ignore(sum depth)\n      done\n\n    let run fn depth = \n      Lwt_fiber.start (fun () -> recurse fn depth)\n  end";
"\n```\n\nThe `recurse` function is deliberately not tail-recursive, so that the callstack increases as the `depth` parameter grows.  The Lwt equivalent is slightly more clunky as we have to rewrite the loop to bind and return:\n\n```\n  module LWT = struct\n    let recurse fn depth =\n      let rec sum n =\n        lwt () = fn () in\n        match n with\n        |0 -> return 0\n        |n ->\n          lwt n' = sum (n-1) in \n          return (n + n')\n      in\n      for_lwt i = 1 to 15000 do\n        lwt res = sum depth in\n        return ()\n      done\n\n   let run = recurse\n  end\n```\n\nWe then run the experiment using the slow `Lwt_unix.sleep 0.0` function, and get this graph:\n\n<img src=\"http://chart.apis.google.com/chart?cht=lxy&amp;chs=600x250&amp;chtt=Recurse%20vs%20basic&amp;chco=FF0000,00FF00,0000FF,FFAA00,AA00FF,00FFFF&amp;chxt=x,x,y,y&amp;chxl=1:|stack-depth|3:|seconds&amp;chds=a&amp;chg=10,10,1,5&amp;chd=t:50,100,200,300,400,600,800,1000|6.264,15.567,44.297,86.823,142.372,310.036,603.735,939.165|50,100,200,300,400,600,800,1000|2.601,5.204,10.401,15.611,20.783,31.221,41.606,52.016|50,100,200,300,400,600,800,1000|2.769,5.564,11.497,17.631,23.826,36.700,49.314,61.794|50,100,200,300,400,600,800,1000|4.011,8.013,15.973,23.995,32.075,47.940,63.966,79.914&amp;chdl=delimcc-recurse-slow|lwt-basic-slow|lwt-recurse-slow|delimcc-basic-slow&amp;chdlp=t&amp;chls=2|2|2|2\"/>\n\nThe above graph shows the recursive Lwt_fiber getting slower as the recursion depth increases, with normal Lwt staying linear.  The graph also overlays the non-recursing versions as a guideline (`*-basic-slow`).\n\n!!Thoughts\n\nThis first benchmark was a little surprising for me:\n\n* I would have thought that `delimcc` to be ahead of Lwt when dealing with functions with a small call-depth and a small amount of blocking (i.e. the traffic pattern that loaded network servers see). The cost of taking a restartable exception seems quite high however.\n* The fiber tests still use the Lwt machinery to manage the callback mechanism (i.e. a `select` loop and the timer priority queue). It may be possible to create a really light-weight version just for `delimcc`, but the Lwt UNIX backend is already pretty lean and mean and uses the [libev](http://software.schmorp.de/pkg/libev.html) to interface with the OS.\n* The problem of having to rewrite code to be Lwt-like still exists unfortunately, but it is getting better as the `pa_lwt` syntax extension matures and is integrated into my [favourite editor](https://github.com/raphael-proust/ocaml_lwt.vim) (thanks Raphael!)\n* Finally, by far the biggest benefit of `Lwt` is that it can be compiled straight into Javascript using the [js_of_ocaml](http://ocsigen.org/js_of_ocaml/) compiler, opening up the possibility of cool browser visualisations and tickets to cool `node.js` parties that I don't normally get invited to.\n\nI need to stress that these benchmarks are very micro, and do not take into account other things like memory allocation. The standalone code for the tests is [online at Github](http://github.com/avsm/delimcc-vs-lwt), and I would be delighted to hear any feedback.\n\n!!Retesting recursion [18th Jun 2011]\n\nJake Donham comments:\n> I speculated in my post that fibers might be faster if the copy/restore were amortized over a large stack. I wonder if you would repeat the experiment with versions where you call fn only in the base case of sum, instead of at every call. I think you're getting N^2 behavior here because you're copying and restoring the stack on each iteration.\n\nWhen writing the test, I figured that calling the thread waiting function more often wouldn't alter the result (careless). So I modified the test suite to have a `recurse` test that only waits a single time at the end of a long call stack (see below) as well as the original N^2 version (now called `recurse2`).\n\n```\n  module Fiber = struct\n    let recurse fn depth =\n      let rec sum n = \n        match n with\n        |0 -> Lwt_fiber.await (fn ()); 0\n        |n -> n + (sum (n-1)) \n      in\n      for i = 1 to 15000 do\n        ignore(sum depth)\n      done\n\n    let run fn depth = ";
"\n      Lwt_fiber.start (fun () -> recurse fn depth)\n  end\n```\n\nThe N^2 version below of course looks the same as the previously run tests, with delimcc getting much worse as it yields more often:\n\n<img src=\"http://chart.apis.google.com/chart?cht=lxy&amp;chs=600x250&amp;chtt=Recurse2%20vs%20basic&amp;chco=FF0000,00FF00,0000FF,FFAA00,AA00FF,00FFFF&amp;chxt=x,x,y,y&amp;chxl=1:|stack-depth|3:|seconds&amp;chds=a&amp;chg=10,10,1,5&amp;chd=t:50,100,200,300,400,600,800,1000|0.282,0.566,1.159,1.784,2.416,3.719,5.019,6.278|50,100,200,300,400,600,800,1000|0.658,1.587,4.426,8.837,14.508,31.066,60.438,94.708&amp;chdl=lwt-recurse2-slow|delimcc-recurse2-slow&amp;chdlp=t&amp;chls=2|2\" /> \n\nHowever, when we run the `recurse` test with a single yield at the end of the long callstack, the situation reverses itself and now `delimcc` is faster. Note that this test ran with more iterations than the `recurse2` test to make the results scale, and so the absolute time taken cannot be compared.\n\n<img src=\"http://chart.apis.google.com/chart?cht=lxy&amp;chs=600x250&amp;chtt=Recurse%20vs%20basic&amp;chco=00FF00,FF0000,0000FF,FFAA00,AA00FF,00FFFF&amp;chxt=x,x,y,y&amp;chxl=1:|stack-depth|3:|seconds&amp;chds=a&amp;chg=10,10,1,5&amp;chd=t:50,100,200,300,400,600,800,1000|0.162,0.216,0.341,0.499,0.622,0.875,1.194,1.435|50,100,200,300,400,600,800,1000|0.128,0.207,0.394,0.619,0.889,1.538,2.366,3.373&amp;chdl=delimcc-recurse-slow|lwt-recurse-slow&amp;chdlp=t&amp;chls=2|2\" />\n\nThe reason for Lwt being slower in this becomes more clear when we examine what the code looks like after it has been passed through the `pa_lwt` syntax extension. The code before looks like:\n\n```\n  let recurse fn depth =\n    let rec sum n =\n      match n with\n      | 0 -> \n          fn () >> return 0\n      | n ->\n          lwt n' = sum (n-1) in \n          return (n + n') in\n```\n\nand after `pa_lwt` macro-expands it:\n\n```\n  let recurse fn depth =\n    let rec sum n =\n      match n with\n      | 0 ->\n          Lwt.bind (fn ()) (fun _ -> return 0)\n      | n ->\n          let __pa_lwt_0 = sum (n - 1)\n          in Lwt.bind __pa_lwt_0 (fun n' -> return (n + n')) in\n```\n\nEvery iteration of the recursive loop requires the allocation of a closure (the `Lwt.bind` call). In the `delimcc` case, the function operates as a normal recursive function that uses the stack, until the very end when it needs to save the stack in one pass.\n\nOverall, I'm convinced now that the performance difference is insignificant for the purposes of choosing one thread system over the other for Mirage.  Instead, the question of code interoperability is more important. Lwt-enabled protocol code will work unmodified in Javascript, and Delimcc code helps migrate existing code over.\n\nInterestingly, [Javascript 1.7](https://developer.mozilla.org/en/new_in_javascript_1.7) introduces a *yield* operator, which [has been shown](http://parametricity.net/dropbox/yield.subc.pdf) to have comparable expressive power to the *shift-reset* delimcc operators. Perhaps convergence isn't too far away after all...\n\n" ]
 | "wiki/dev-preview-checklist.md" | "/wiki/dev-preview-checklist.md" -> Some ["!Developer Preview Checklist\n\n!!Scenarios\n\nThree scenarios need to work:\n\n* Stub-domains for Xenstore and Xenconsoled. Device drivers (mainly netfront and blkfront) should compile on both Xen and Linux to let us swap between front-ends and back-ends as either stub-domain or dom0.\n\n* Self-hosting website and DNS server (this one!).\n\n* Proof concept of distributed system (ideally can be demo'd for OSCON). Current thinking is something like OCamlot or Signpost. This would be a nice \"Hello world!\" demo as it requires actors and a persistent job queue. For example, i.e spawning new VMs in response to load, as evidenced by self-scaling web-server.\n\n!!Repositories\n\nAll of these repositories need to be code-reviewed and run over with ocamldoc.  Purge the TODO hacks when you go over them, or explicitly pull them out into a top-level TODO file.\nWe need to close out this thread on a standard [repository format](https://lists.cam.ac.uk/pipermail/cl-mirage/2013-March/msg00099.html) for all these things.\n\nCore Unix/Xen libraries:\n* *shared-memory-ring*: Builds shared memory-based point-to-point communication protocols. Is reasonably mature and can be released. Can be used outside of Xen, need to benchmark vs c. 4.01.0dev ocaml improves perf with bigarray builtins. Implements the Xen ABI, but needs examples in-tree. (Owner: djs). For 1.0.\n* *ocaml-xenstore*: Repo layout is confusing. Client and server in here, as well as Lwt bindings. Does build as stub domain and unix kernel. How can this stay in sync with xen-unstable? (Owner: djs). For 1.0.\n* *ocaml-fd-send-recv*: UNIX only and trivial. Released and stable. For 1.0. (Owner: djs/vb)\n* *ocaml-vchan*: Vchan communication channel between VMs.  Provides a socket-like interface between VMs.  For 1.0 (Owner: djs).  Post 2.0: vsock?\n* *ocaml-qmp*: QEMU message-passing protocol to command a running qemu. Not for 1.0, really for advanced use (Owner: djs).\n* *ocaml-gntshare*: Interface to mapping pages across Xen VMs. In ocaml-xen-lowlevel-libs, in good state, part of upstream xen-unstable and needs synching. (Owner: djs)\n* *ocaml-xen-block-driver*: Successfully moved out, and works in Xen. It once worked in userspace. (Owner: djs/jonludlam). For 1.0.\n* *ocaml-xen-net-driver*: Can be moved out, and works in Xen. It once worked in userspace. (Owner: djs/jonludlam). For 1.0.\n* *xenbigarray*: OPAM switch hack to eliminate unix dependency. shouldnt be externally visible. (Owner: anil). For 1.0.\n\nCore Mirage libraries and tools:\n* *mirage-platform*:\n* *ocaml-cstruct*:\n* *mirari*:\n* *opam-repo-dev*:\n* *dyntype*:\n* *ocaml-re*: stable, done\n* *opam*: \n* *cross-ref ocamldoc*: leo\n\nStorage libraries:\n* *mirage-fs*: FAT not working as depends on Bitstring. Post 1.0, break out FAT into separate library. VB expressed interest in FAT.\n* *orm*: Post 1.0, needs sqlite bindings\n* *ocaml-crunch*: Works.\n* *libvhd*: ?? Jon, suitable for block driver use?\n* *ocaml-iscsi*: Doesnt exist, but djs really wants it.\n* *cagit*: Needs a file system (Owner: tg).\n* *irminsule*: tg, not for 1.0\n* *arakoon*: In-memory-only patch, Arakoon already functorised across the storage layer. For 1.0? to investigate\n\nRPC/coordination:\n* *rpc-light*: Works well, but slow and no wire protocol defined. Vb mentioned Thrift. Also have bin_io? No versioning story. Needs obuild help. (Owner: tg)\n* *ocaml-actor*: non existent!\n* *ocaml-fable*: on avsm repo only \n* *message-switch*: \n* *ocamlmq*: to investigate.\n* *logger*: need a vchan-based logger and CLI to access from other domain\n\nProtocols:\n* *ocaml-dns*:\n* *mirage-net*:\n* *ocaml-pcap*:\n* *ocaml-openflow*:\n* *ocaml-xmpp*: ermine repos, lwt, need porting to mirage-net\n\nSecurity:\n* *mirage-cryptokit*:\n* *ocaml-crypto-keys*:\n* *stud*: need ssl binding for fable\n* *ocaml-ssh*: still in mpl-land, not too hard to port\n\nWebby libraries:\n* *ocaml-cohttp*: \n* *ocaml-cow*:\n* *ocaml-uri*:\n* *ocaml-spdy*: out of date, not for 1.0\n\nCloud interfaces:\n* *aws*: ec2 bindings, need porting to cohttp\n* *ocaml-libvirt*: dave upstreaming\n* *xenopsd*: convenient single-host daemon for ubuntu-unstable.\n\n\nTesti";
"ng:\n* Ocamlot\n* [Pathos](https://lists.cam.ac.uk/pipermail/cl-mirage/2013-February/msg00042.html) testing?\n\nTutorials and examples:\n* *mirage-skeleton*:\n* *mirage-tutorial*: out-of-date\n* *mirage-www*: extract wiki/blog into library, make it not suck\n\n!!Misc\n\n* Integrate `ocaml-tuntap` into `mirage-platform` to remove tun hacks [vincent]\n* `mirari run` as a stateful process working with libvirt and EC2.\n* cohttp/ssl releases [anil]\n* obuild instead of oasis for core libraries for better cross-compilation/portability/speed\n* Jenga? [dave]\n\n\n" ]
 | "wiki/hello-world.md" | "/wiki/hello-world.md" -> Some ["First make sure you have followed the [installation\ninstructions](/wiki/install).  Mirage uses [Mirari](/blog/mirari) to\nautomate the configuration and setup the build system necessary to\nbuild Mirage unikernels.\n\n!!First Steps\nTo try out basic functionality and build a UNIX binary, do:\n\n```\n    $ git clone git://github.com/mirage/mirage-skeleton.git\n    $ cd mirage-skeleton/basic\n    $ cat basic/hello.ml\n    $ make\n    $ ./mir-hello\n```\n\nThis will just starts up a Xen kernel that prints \"hello world\" with a\nshort pause between words. Now build a Xen version of this:\n\n```\n    $ opam switch 4.00.1+mirage-xen\n    $ eval `opam config env`\n    $ make clean && make\n```\n\nThis will create a symlink to `./dist/build/mir-hello/mir-hello.xen`,\nand you can boot it up with a config file like:\n\n```\n    $ cat > hello.cfg\n    name=\"hello\"\n    memory=128\n    kernel=\"mir-hello.xen\"\n    vif=['bridge=xenbr0']\n    <control-d>\n    # Use xm instead of xl if you are using Xen 4.1 or older\n    $ sudo xl create -c hello.cfg\n```\n\nYou should see the same output on the Xen console as you did on the\nUNIX version you ran earlier.  If you need more help getting a Xen\nkernel booted, try looking at the [Xen notes](/wiki/xen-boot) also.\n\n!!Networking\n\nMirage networking is present in the `Net` module and can compile in two modes:\n\n* A `direct` mode that works from the Ethernet layer (the `OS.Netif`\n  module). On Xen, this is the virtual Ethernet driver, and on UNIX\n  this requires the `tuntap` interface. You can link in this `Net`\n  module by using the `xen` or `unix-direct` backends for Xen and UNIX\n  respectively.\n\n* A subset of the Net modules (`Flow`, `Channel` and `Manager`) are\n  available in 'socket' mode under UNIX. This maps the interfaces onto\n  POSIX sockets, enabling easy comparison with normal kernels. This is\n  only supported under UNIX via the `unix-socket` backend.\n\nWhen building a Mirage unikernel, `mirari` automatically include\nboilerplate code that uses the `Net.Manager` module. On the `direct`\nmode, your kernel will answer ping requests, as you can verify by\nissuing the following commands:\n\nUnix:\n\n```\n    $ opam switch 4.00.1+mirage-unix\n    $ eval `opam config env`\n    $ make\n    $ sudo ./mir-hello\n    $ ping 10.0.0.2\n```\n\nXen:\n\n```\n    $ opam switch 4.00.1+mirage-xen\n    $ eval `opam config env`\n    $ make\n    $ sudo xl create -c hello.cfg\n     <configure the bridge IP address>\n    $ telnet 10.0.0.2 8081\n```\n" ]
 | "wiki/htcaml.md" | "/wiki/htcaml.md" -> Some ["In this post I introduce [HTCaML](http://www.github.com/samoht/htcaml)\nand explain how to use it to generate static HTML from within OCaml applications. It consists of:\n\n* a quotation mechanism to embed XML into an OCaml program.\n* a syntax extension to auto-generate boilerplate HTML definitions from OCaml type definitions.\n\n!!HTML quotations\n\nLet us first focus on the quotation mechanism. This part is quite\nsimilar to the syntax extension provided by\n[Eliom](http://ocsigen.org/eliom/manual/1.3.0/), but exposed as\nexplicit `<:html< ... >>` quotations. This lets us compose HTCaML with\nother language quotations (such as CSS) in the same file.\n\nLet us start with an example. We would like to display a list of tweets\nstored locally. As for any OCaml program, we need to start thinking first\nabout the data structures to use. So let us define one:\n\n```\ntype author = {\n name : string;\n link : string;\n}\n```\n\nfor the `author` type and:\n\n```\ntype tweet = {\n  author = author;\n  date = Date.t;\n  contents = Html.t\n}\n```\n\nfor the `tweet` type. We assume here that we have already defined in our\ncode a module `Date` which manipulates date formats. `Html.t` is\npart of the HTCaML library and is the type of HTML fragments.\n\nWe can now define the functions converting any value of type `tweet`\ninto an HTML fragment. Let us start with `val html_of_author : author -> Html.t`:\n\n```\nlet html_of_author a =\n   <:html<\n      <a href=$str:a.link$>$str:name$</a>\n   >>\n```\n\nFragments of code written between `$` are called \"antiquotations\", and\nare valid OCaml code not interpreted by the HTML parser; the\n(optional) prefix first of the antiquotation is a hint to the compiler\nto understand the type of the value returned by the antiquotation. The\ncode above will automatically be expanded by `camlp4` into:\n\n```\nlet html_of_author a =\n   Html.Tag (\"a\",\n     Html.Prop(href,\n       Html.String a.link),\n     Html.String name)\n```\n\nNext, we can write the code for `val html_of_tweet : tweet -> Html.t`:\n\n```\nlet html_of_tweet t =\n   <:html<\n      <div class=\"tweet\">\n        <div class=\"author\">$html_of_author t.author$</div>\n        <div class=\"date\">$Date.html_of_date t.date$</div>\n        <div class=\"contents\">$t.contents$</div>\n      </div>\n   >>\n```\n\nNote that we do not need to add a prefix to the antiquotations here as\nthe `html_of_*` functions already return a value of type `Html.t`, and so\nno translation from other types (e.g. a `string`) is required.\n\nThen, using `val Html.to_string : Html.t -> string`, it is\nstraightforward to process a list of tweet values in order to generate\na static HTML page:\n\n```\nlet process tweets =\n    let html = <:html<\n      <html>\n        <head>\n          <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"/>\n        </head>\n        <body>\n          My collection of tweets :\n          $list:List.map html_of_tweet tweets$\n        </body>\n      </html>\n    >> in\n    let chan = open_out \"tweets.html\" in\n    output_string chan (Html.to_string html);\n    close_out chan\n```\n\nFinally, we can use [CaSS](http://www.github.com/samoht/cass) to produce\na very simple CSS files. CaSS provides CSS quotations to convert CSS\nfragments into an OCaml program:\n\n```\nlet () =\n  let color = <:css< black >> in\n  let css  = <:css<\n    .tweet           { background: yellow; color: $color$; }\n    .tweet .author   { display: inline; }\n    .tweet .date     { display: inline; }\n    .tweet .contents { font-style: italic; }\n  >> in\n  let chan = open_out \"style.css\" in\n  output_string chan (Css.to_string css);\n  close_out chan\n```\n\n!!HTML Generator\n \nSome of the OCaml code we wrote in the last section is quite tedious\nto write. Let us consider `html_of_tweet` again:\n\n```\nlet html_of_tweet t =\n   <:html<\n      <div class=\"tweet\">\n        <div class=\"author\">$html_of_author t.author$</div>\n        <div class=\"date\">$Date.html_of_date t.date$</div>\n        <div class=\"contents\">$t.contents$</div>\n      </div>\n   >>\n```\n\nTo write this code fragment, we had to reason by\ninduction on the type structure of `tweet`. So this piece of code can\nbe generated automatically, given a way ";
"to obtain a dynamic representation of the\ntype structure. That is exactly what the\n[DynType](http://www.github.com/samoht/dyntype) library does!\nUsing DynType, HTCaML can auto-generate `html_of_t` when the type definition of\n`t` is annotated by the keywords `with html`. However, we still want\nto be able to manually write the translation to HTML, as for the\n`author` type above.\n\nSo we can rewrite the previous example:\n\n```\ntype author = {\n name : string;\n link : string;\n}\n\nlet html_of_author a =\n   <:html<\n      <a href=$str:a.link$>$str:name$</a>\n   >>\n\ntype tweet = {\n  author = author;\n  date = Date.t;\n  contents = Html.t\n} with html\n```\n\nAnd `html_of_tweet` will pick the right definition of `html_of_author`.\n" ]
 | "wiki/index.md" | "/wiki/index.md" -> Some ["Welcome to the Mirage wiki. Feel free to subscribe to the [Atom](/wiki/atom.xml) feed to keep up-to-date with our progress.\nMirage is still in pre-alpha stage, but the infrastructure you see here is self-hosting. The authors hang on out #mirage on FreeNode IRC, so drop by with any questions you might have.\n\n*Usage*\n\n* [Installation](/wiki/install)\n* [Hello Mirage World](/wiki/hello-world)\n* [Running Mirage Xen kernels in the cloud](/wiki/xen-boot)\n* [Source code layout](/wiki/source-code-layout)\n\n*Media*\n* [Technical Talks](/wiki/talks)\n* [Publications and Related Work](/wiki/papers)\n* [Tutorial Slides](http://tutorial.openmirage.org)\n\n*Technical*\n* Threads: [introduction to Lwt](/wiki/tutorial-lwt)\n* Threads: [delimited continuations vs explicit monadic threads](/wiki/delimcc-vs-lwt)\n* [Developing the networking stack on UNIX](/wiki/running-ethernet-stack-on-unix)\n* [DNS Performance Tests](/wiki/performance)\n* [Portable Regular Expressions](/wiki/ocaml-regexp)\n* [HTCaML](/wiki/htcaml)\n* [Caml on the Web (COW)](/wiki/cow)\n\n*Release Notes*\n* [Checklist for 1.0 Dev Preview](dev-preview-checklist)\n* Weekly call [2013-06-11](/wiki/weekly-2013-06-11) on the end of the start is finally in sight.\n* Weekly call [2013-06-04](/wiki/weekly-2013-06-04) on Amazon EC2, shared ring performance and outreach.\n* Weekly call [2013-05-28](/wiki/weekly-2013-05-28) on build pain reduced to mild ache, TryMirage and benchmarking.\n* Weekly call [2013-05-21](/wiki/weekly-2013-05-21) on build, build, and more build, argh.\n* Weekly call [2013-05-14](/wiki/weekly-2013-05-14) on Ocamlot, actors and performance.\n* Weekly call [2013-04-30](/wiki/weekly-2013-04-30) on device drivers, SSL, actors and OpenFlow.\n* Weekly call [2013-04-23](/wiki/weekly-2013-04-23) on Irminsule, revisions and release.\n* Weekly call [2013-04-16](/wiki/weekly-2013-04-16) on release, libvirt and Mirari.\n" ]
 | "wiki/install.md" | "/wiki/install.md" -> Some ["Mirage consists of a set of OCaml libraries that link with a runtime to form either a standalone Xen operating system or a normal UNIX binary. These libraries are managed via the [OPAM](http://opam.ocamlpro.com) tool. We will first introduce the basics of OPAM, and then describe the libraries you need to get on with using Mirage.\n\nOPAM manages simultaneous OCaml compiler and library installations. It tracks library versions across upgrades, and will recompile dependencies automatically if they get out of date. Please refer to OPAM [documentation](https://opam.ocamlpro.com) if you want to know more, but we will cover the basics to get you started here.\n\n!!Requirements\n\nMirage has been tested on Archlinux, Debian Wheezy, Ubuntu Lucid/Raring and MacOS X 10.7 and 10.8. To compile the Xen backend, you *must* have a 64-bit Linux host. 32-bit is not supported at this time.\n\nInstall OPAM for your operating system by following its [Quick Install Guide](http://opam.ocamlpro.com/doc/Quick_Install.html).\n\nIf you're using MacOS X, you will also need the [tuntap](http://tuntaposx.sourceforge.net/) kernel module if you want to use the direct networking stack.\n\n!! Using OPAM\n\nAll the OPAM state is held in the `.opam` directory in your home directory, including compiler installations. You should never need to switch to a root user to install packages. Package listings are obtained through `remote` sources, which defaults to the contents of [github.com/OCamlPro/opam-repository](http://github.com/OCamlPro/opam-repository).\n\n```\n$ opam init\n```\n\nThis initialises OPAM and adds the `default` repository to your package list. In the future, an `opam update` will refresh the package list, and an `opam upgrade` will recompile packages to the latest versions.\n\nNext, make sure you have OCaml 4.00.1 as your active compiler. This is\ngenerally the case on MacOS X, but Debian lags behind. But don't worry: if\nyour compiler is out of date, just run `opam switch` to have it locally\ninstall the right version for you.\n\n```\n$ ocaml -version\n# if it is not 4.00.1, then run this\n$ opam switch 4.00.1\n```\n\nN.B. The above step is currently also necessary on MacOS X as the `opam` installation of `ocamlfind` assumes that `ocamlfind` is placed in the same directory as the `ocaml` compiler. When using the `system` switch, this is not the case: `ocaml` is in `/usr/local/bin/ocaml` but `ocamlfind` is in `~/.opam/system/bin/ocamlfind`.\n\nOnce you've got the right version, set up your current shell environment.\n\n```\n$ eval `opam config env`\n# add the above line to your startup shell profile\n$ opam install mirari\n```\n\nThis updates the variables in your shell to match the current OPAM installation, mainly by altering your system `PATH`. You can see the shell fragment by running `opam config env` at any time. If you add the `eval` line to your login shell (usually `~/.bash_profile`), it will automatically import the correct PATH on every subsequent login.\n\nFinally, `opam install mirari` will install the [Mirari](https://github.com/mirage/mirari) tool\nthat acts as a build frontend for Mirage applications. This gives you\neverything you need to [build the website for yourself!](/wiki/mirage-www)\n\n!! Switching Compiler Instances\n\nThe default compiler installed by OPAM uses the system OCaml installation. You can use `opam switch` to swap between multiple cross-compilers; each compiler installation is customised to build for a specific Mirage target by installation of the correct opam packages.\n\nIf you are on 64-bit Linux, let's get the Xen cross-compiler working.\n\n```\n$ opam switch 4.00.1+xen -a 4.00.1\n$ eval `opam config env`\n$ opam install mirari mirage-xen\n```\n\nThe `opam switch` command will show you the available compilers. The `switch` above will install the compiler into `~/.opam/4.00.1+xen`, with the compiler binaries in `~/.opam/4.00.1+xen/bin`, and any libraries installed into `~/.opam/4.00.1+xen/lib`. The `opam config` will detect the current compiler and output the correct `PATH` for your compiler installation. Installation of the `mirari` and `mirage-xen` packages should ensu";
"re that you have the correct libraries installed to build for Xen. (A well-written mirari config file should specify any necessary dependencies though --- see [detail for building the Mirage website](/wiki/mirage-www) for details.)\n" ]
 | "wiki/mirage-www.md" | "/wiki/mirage-www.md" -> Some ["\nBuilding this mirage website using UNIX sockets should be straightforward once `mirari` has successfully installed.\n\n```\n$ git clone git://github.com/mirage/mirage-www\n$ cd mirage-www\n$ make unix-socket-build\n$ sudo make run\n```\n\nNB. If your build fails complaining about `xmlm.cma` not being found, this is a minor bug currently being ironed out. The workaround is to downgrade the `cow` package via `opam install cow.0.5.5 && opam pin cow 0.5.5`.\n\nThis will run the website on `localhost:80`, using normal kernel sockets.\n\n!! Using Mirage's network stack\n\n```\n$ opam remove mirage-net-socket\n$ make clean unix-direct-build\n$ sudo make run\n```\n\nThis will remove the `mirage-net-socket` package, which configures the current compiler switch to use the local kernel sockets libraries for network access; and then install the `mirage-net-direct` package, which configures the compiler switch to use Mirage's native OCaml network stack instead.\n\nVisit this alternate yet functionally identical build of the website via [http://10.0.0.2](http://10.0.0.2).\n\nThese two packages conflict and so cannot be installed simultaneously in a single compiler switch. As removing these packages can cause other packages to have to be rebuilt, and this can take some time, you may prefer to setup aliased compiler switches within which to have each version.\n\n```\n$ opam switch 4.00.1+mirage -a 4.00.1\n$ eval `opam config -env`\n$ opam install mirari\n$ make clean unix-direct-build\n$ sudo make run\n```\n\nRebuilding using your native UNIX socket libraries is then as simple as\n\n```\n$ opam switch 4.00.1\n$ eval `opam config -env`\n$ make clean unix-socket-build\n$ sudo make run\n```\n\n!! Building the Website as a Xen Unikernel\n\nNow try to compile up a Xen version of this website, via:\n\n```\n$ opam switch 4.00.1+xen -a 4.00.1\n$ eval `opam config -env`\n$ opam install mirari\n$ make clean xen-build\n```\n\nThere will be a symbolic link to your Xen microkernel in the current working directory: learn how to run it [here](/wiki/xen-boot).\n" ]
 | "wiki/net-unix.md" | "/wiki/net-unix.md" -> Some ["Mirage applications can be compiled all into micro-kernels, and so have to handle traffic from [Ethernet](http://en.wikipedia.org/wiki/Ethernet) and up.  Ethernet is a low-level protocol that encapsulates [IPv4](http://en.wikipedia.org/wiki/Internet_protocol), which in turns drives the reliable [TCP](http://en.wikipedia.org/wiki/Transmission_Control_Protocol) protocol.  This web-page is then served over the [HTTP](http://en.wikipedia.org/wiki/HTTP) request/response protocol. The Mirage standard library includes an implementation of all these protocols, written in pure OCaml.\n\nActually developing complex code in a micro-kernel environment is not terribly productive, as you do not have access to the usual UNIX debugging tools.  Luckily, many variants of UNIX provide the facility to \"tap\" Ethernet traffic into user-space directly via the [Tuntap](http://en.wikipedia.org/wiki/Tuntap) interface.  This page describes how to get Mirage up and running with Ethernet traffic under UNIX.\n\n* First, ensure you have a working Mirage installation by following the [INSTALL](https://github.com/avsm/mirage/blob/master/INSTALL.md) file in the source repository. You can verify it by running `cd tests/basic/sleep && mir-unix-direct sleep.bin && ./_build/sleep.bin` from the root source directory.\n\n* Next, make sure your operating system supports the `tuntap` driver. On MacOS X, you will need to install [TunTapOSX](http://tuntaposx.sourceforge.net/). Most Linux distributions will have it already enabled by default. I havent had a chance to run this on *BSD yet; it will likely require a minor patch to the [driver](http://github.com/avsm/mirage/tree/master/lib/os/runtime_unix) as the `ioctl` interface varies between implementations.\n\n* Build `tests/net/tcp_echo` by `cd tests/net/tcp_echo && mir-unix-direct echo.bin` from the root of the source repository. If successful, you then run `sudo ./_build/echo.bin`, that should start up on the interface.\n\n* The details of how to connect now vary by OS:\n\n\t* MacOS X unfortunately does not support Ethernet bridging, which means that you cannot talk to the outside world. The driver automatically assigns an IP address of `10.0.0.1 netmask 255.255.255.0` to the `tun0` interface ([see code](https://github.com/avsm/mirage/blob/master/runtime/unix/tap_stubs_macosx.c#L60)). The test application uses `10.0.0.2` for itself, and so you can test it by `ping 10.0.0.2`. If you see ping replies, and some debug output from the application, you are set!\n\n\t* Linux does support bridging, but this is not set up by default. After running the test application, run `ifconfig tap0 10.0.0.1 netmask 255.255.255.0` to set up the `tap0` interface (remember the interface will not be created until the application is run, so you cannot configure it before). Then try to `ping 10.0.0.2` and see if you get a response.\n\n\t* The network stack is configured statically at the moment by editing `lib/net/direct/config.ml`. Select the right function (either DHCP or a static IP assignment) and applications will be compiled with the right policy. In the future, we plan to add a configuration syntax extension that will add the right configuration module at application build-time (rather than the Mirage library build-time as it currently is).\n\n* Once this is working, you can play around with the rest of the protocol stack in `lib/net/direct`:\n\n\t* [ARP](http://en.wikipedia.org/wiki/Address_Resolution_Protocol) translates between Ethernet MAC addresses and IP addresses.\n\t* [ICMP](http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol) is a control protocol for IP, usually to send back errors.  [IPv4](http://en.wikipedia.org/wiki/Internet_Protocol_Suite) is in [lib/net/direct/ipv4.ml](https://github.com/avsm/mirage/blob/master/lib/net/direct/ipv4.ml).\n\t* The datagram protocol [UDP](http://en.wikipedia.org/wiki/User_Datagram_Protocol) is in [lib/net/direct/udp.ml](https://github.com/avsm/mirage/blob/master/lib/net/direct/udp.ml), and an experimental [TCP](http://en.wikipedia.org/wiki/Transmission_Control_Protocol) stack is in [lib/net/direct/tcp.";
"ml](https://github.com/avsm/mirage/blob/master/lib/net/direct/tcp.ml).\n\t* If you have Ethernet bridging, you can use the [DHCP](http://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol) client in [lib/net/direct/dhcp/client.ml](https://github.com/avsm/mirage/blob/master/lib/net/direct/dhcp/client.ml) to get an IP address.\n\t* Finally, a full [DNS](http://en.wikipedia.org/wiki/Domain_Name_System) server exists in [lib/net/dns](https://github.com/avsm/mirage/tree/master/lib/net/dns). No DNS client exists, but it should be fairly easy to extend the server code.\n\nIf you want to modify the code, then just edit any of those ML files, and type in `make && make install` at the top-level of the repository, and then rebuild the application. You should get familiar with the `tcpdump` utility, and graphical ones like [Wireshark](http://www.wireshark.org/). Run these against the `tap0` interface, for example:\n\n```\n$ sudo tcpdump -i tap0 -vvvx\n```\n\nThis will show you the protocol traffic appearing on the bridge.\n" ]
 | "wiki/ocaml-regexp.md" | "/wiki/ocaml-regexp.md" -> Some ["Mirage targets different backends: micro-kernels for the Xen hypervisor, Unix\nexecutables and Javascript programs. The recent inclusion of the Javascript\nbackend makes many C bindings unsuitable. In order to push backend incompatibilities\ncloser to the application level, it is necessary to either reimplement the C\nbindings in Javascript or OCaml, or remove them completely. This is particularly\nimportant for the standard library.\n\n!!The `Str` module has to go!\n\n`Str` provides regular expressions in a non-reentrant, non-functional fashion.\nWhile the OCaml distribution provides it in `otherlibs`, it is installed by\ndefault and so widely used, and implemented under the hood via a C library.\nRegular expressions are used in several places in Mirage, mainly for small\noperations (splitting, getting an offset, etc.), and so having a portable\nfallback written in pure OCaml would be very useful.\n\nThere are several possible ways to replace the `Str` module, each with its own\nset of perks and drawbacks:\n* Use a backend-neutral regexp library which \"translates\" to either `Str`\n  or `Pcre` for the Xen and Unix backends or Javascript native regexps for\n  the Javascript backend. This solution may be hard to maintain, especially if a\n  fourth backend is to be included. Moreover each regexp library uses a slightly\n  different convention for regexps (e.g. see the\n  [magic](http://vimdoc.sourceforge.net/htmldoc/pattern.html#/magic) option in\n  vim) which means that a lot of translation code might be needed.\n* Do string processing without regexps (using `String.index` and the likes).\n  This solution is portable and potentially efficient. However, the potential\n  efficiency comes from a low-level way of doing things.\n* Use an OCaml regexp library without C bindings. We expected such a library to\n  be slower than `Str` and needed an estimation of performance cost in order to\n  assess the practicality of the solution.\n\n!!Benchmarking `Str`\n\nThere is a purely OCaml regexp library readily available, called `Regexp` and\ndeveloped by Claude Marché from the LRI laboratory. You can find the\ndocumentation and the source on the associated\n[webpage](http://www.lri.fr/~marche/regexp/). After getting rid of mutexes\n(which, in Mirage, are of no use, because of the `Lwt` based\nconcurrency), we benchmarked it against `Str`. We also included the popular\n`Pcre` (Perl Compatible Regular Expression) library that is widely used.\n\nThe benchmark (available [on github](http://github.com/raphael-proust/regexp-benchmark.git))\nis really simple and measures three different factors:\n* regexp construction: the transformation of a string (or another representation\n  available to the programmer) into the internal representation of regexps used\n  by the library\n* regexp usage: the execution of operations using regexps\n* string size: the length of the string being matched\n\nMirage uses regexp in a specific pattern: a limited number of regexp\nconstructions with a potentially high number of invocation (e.g. HTTP header parsing).\nThe size of the strings on which regexps are used may vary.  Because of this pattern,\nour benchmark does not take regexp construction overhead into account.\n\nHere are the execution times of approximately 35000 string matching operations\non strings of 20 to 60 bytes long.\n\n<img src=\"/graphics/all_1_1000_10.png\"/>\n\nQuite surprisingly for the string matching operation, the C based `Str` module\nis less efficient than the pure OCaml `Regexp`. The `Pcre` results were even worse\nthan `Str`. Why?\n\n!!!A simple library for a simple task\n\nThe `Regexp` library is lightweight, and so far faster than its C based\ncounterparts. One of the features `Regexp` lacks is \"group capture\": the ability\nto refer to blocks of a previously matched string. In `Pcre` it is possible to\nexplicitly and selectively turn group capturing off via special syntax,\ninstead of the regular parentheses. `Str` does not offer  this, and thus\nimposes the runtime cost of capture even when not necessary. In other words, the\nslowdown/group capturing \"is not a feature, it's a bug!\"\n\n!!!The Mirage Regexp";
" library\n\nWith the introduction of `Regexp` into the tree, the libraries available to Mirage\napplications are now `Str`-free and safer to use across multiple backends. The main\ndrawback is a slight increase in verbosity of some parts of the code.\nBenchmarking the substitution operation is also necessary to assess the\nperformance gain/loss (which we will do shortly).\n\nIn addition to cosmetic and speed considerations, it is important to consider the\nportability increase: Mirage's standard library is [Node.js](http://nodejs.org) compatible,\na feature we will explore shortly!\n" ]
 | "wiki/opam.md" | "/wiki/opam.md" -> Some ["!!! Maintenance\n\nThe `opam upgrade` command will refresh all your remote repositories, and recompile any outdated libraries. You will need to run this once per compiler installed, so switch between them.\n\nIf you run into any problems with OPAM, then first ask on the Mirage [mailing list](/about), or report a [bug](http://github.com/OCamlPro/opam/issues). It is safe to delete `~/.opam` and just start the installation again if you run into an unrecoverable situation, as OPAM doesn't use any files outside of that space.\n\n!!! Development\n\nThere are two kinds of OPAM remote repositories: `stable` released versions of packages that have version numbers, and `dev` packages that are retrieved via git or darcs (and eventually, other version control systems too).\n\nTo develop a new package, create a new `opam-repository` Git repo.\n\n```\n$ mkdir opam-repository\n$ cd opam-repository\n$ git init\n$ mkdir packages\n$ opam remote add mypkg .\n```\n\nThis will configure your local checkout as a development remote, and OPAM will pull from it on every update. Each package lives in a directory named with the version, such as `packages/foo.0.1`, and requires three files inside it:\n\n* `foo.0.1/url` : the URL to the distribution file or git directory\n* `foo.0.1/opam` : the package commands to install and uninstall it\n* `foo.0.1/descr` : a description of the library or application\n\nIt's easiest to copy the files from an existing package and modify them to your needs (and read the [doc](http://opam.ocamlpro.org) for more information). Once you're done, add and commit the files, issue an `opam update`, and the new package should be available for installation or upgrade.\n" ]
 | "wiki/repo-layout.md" | "/wiki/repo-layout.md" -> Some ["This post explains how the Mirage [source repository](http://github.com/avsm/mirage) is laid out for you to browse.  Note that building an operating system consists of a million little details. Mirage is still very much a work-in-progress, so don't be surprised if you run into `TODO` markers all over the source. Better still, fork it on [Github](http://github.com/avsm/mirage) and send a pull request with your fix!\n\n!!Build\n\nMirage uses [OCamlbuild](foo) to build the tools and libraries. We build three types of things, each with their own `myocamlbuild.ml` plugin to handle the build dependencies:\n * [tools/](http://github.com/avsm/mirage/tree/master/tools) that help with builds, using the host OCaml toolchain.\n * [syntax/](http://github.com/avsm/mirage/tree/master/syntax) extensions, which also use the host OCaml toolchain and are invoked when building Mirage applications, but are themselves never linked in to the output.\n * [lib/](http://github.com/avsm/mirage/tree/master/lib/) which holds the Mirage OCaml standard library and C/Javascript runtime files for the various backends.\n\nOCamlbuild is a powerful build tool due to its support for dynamic dependency generation, but does take some learning. Please see the [users guide](http://nicolaspouillard.fr/ocamlbuild/ocamlbuild-user-guide.pdf) for more documentation or ask one of the Mirage team.\n\n!!Toolchain\n\nMirage requires an OCaml 3.12.0 toolchain to be installed, and does not require patching it (instead, we supply a complete replacement standard library). There are a few tools we build as they are tightly coupled with the way Mirage works:\n\n* [tools/mpl](http://github.com/avsm/mirage/tree/master/tools/mpl/) is the Meta Packet Language (MPL) specification compiler, used to convert Internet packet formats into OCaml parsing and construction modules. It is described in this [EuroSys 2007 paper](http://anil.recoil.org/papers/2007-eurosys-melange.pdf).\n* [tools/crunch](http://github.com/avsm/mirage/tree/master/tools/crunch/) is a \"poor man's type-safe memory filesystem\". It is a command-line tool that reads in a directory of files, and outputs an OCaml module that serves those files directly as strings. Very useful when the storage sub-system isn't working yet, or (as with this website) everything can be served from RAM easily anyway.\n* [tools/mir](http://github.com/avsm/mirage/tree/master/tools/mir/) has the build scripts that wrap ocamlbuild and set the right environment variables for the desired backends.\n\n!!Syntax \n\nOCaml has a sophisticated syntax extension mechanism known as [camlp4](http://brion.inria.fr/gallium/index.php/Camlp4). Learn the basics by reading Jake Donham's superb [blog series](http://ambassadortothecomputers.blogspot.com/search/label/camlp4) explaining its intricacies.\n\nMirage bundles a base set of extensions and bundles them into the [syntax/](http://github.com/avsm/mirage/tree/master/syntax/) directory. This simplifies life considerably from a build perspective and ensures all the extensions used play well together. The distribution currently includes the [LWT](http://ocsigen.org/lwt/doc/api/Pa_lwt.html) extension, the [type-conv](http://hg.ocaml.info/release/type-conv) extension for type-driven meta-programming, the dynamic typing [dyntype](http://github.com/mirage/dyntype) extension, and the [XML](/wiki/htcaml) and [COW](/wiki/cow) web programming helpers.\n\n!!Libraries\n\nThe [lib/](http://github.com/avsm/mirage/tree/master/lib/) directory is where the Mirage standard library code lives.\n\n!!!OCaml\n\nWe implement as much of Mirage in pure OCaml as possible, which can be found in:\n\n* [lib/std/](http://github.com/avsm/mirage/tree/master/lib/std/) has the replacement standard library. This consists of the OCaml upstream standard library, but somewhat stripped down to remove OS-specific constructs (mainly the `Thread` module as Mirage does not have preemptive threading). For convenience, we also add the core of the [LWT](http://ocsigen.org/lwt/) co-operative threading library and the Ulex Unicode library by Alain Frisch.\n\n* [lib/os/](http://github.com/avsm";
"/mirage/tree/master/lib/os) contains backends for each operating system. This is the low-level code that drives the event loop and device drivers. [lib/os/xen/](http://github.com/avsm/mirage/tree/master/lib/os/xen/) has the Xen micro-kernel code, [lib/os/unix/](http://github.com/avsm/mirage/tree/master/lib/os/unix) has the POSIX platform code, and [lib/os/node/](http://github.com/avsm/mirage/tree/master/lib/os/node) has the Node.JS code.  Each library maintains a common signature sub-set, so if the platform supports (for example) an Ethernet driver, then that module will have the same signature. At build-time, the relevant module is automatically copied into the standard library as the `OS` module, so the source code never sees the alternative implementations unless it is recompiled using a different backend.\n\n* [lib/net/](http://github.com/avsm/mirage/tree/master/lib/net/) contains the low-level networking code. There are two versions, [lib/net/direct/](http://github.com/avsm/mirage/tree/master/lib/net/direct) which implements Ethernet, ARP, UDP, TCP/IP and DHCP, and [lib/net/socket/](http://github.com/avsm/mirage/tree/master/lib/net/socket) that maps onto UNIX sockets. As with the OS module, only one of these is chosen at build-time depending on the backend in use: e.g. `xen-direct` uses the direct library, and `unix-socket` the socket version.\n\n* [lib/dns/](http://github.com/avsm/mirage/tree/master/lib/dns/) is a DNS server implementation. The data structures are described in Tim Deegan's PhD thesis on the \"[Main Name System](http://www.tjd.phlegethon.org/words/thesis.pdf)\".\n\n* [lib/http/](http://github.com/avsm/mirage/tree/master/lib/http/) is a HTTP client and server, with support for HTTP/1.1, pipelining and chunked transfers. It is a fork of the [cohttp](http://github.com/avsm/ocaml-cohttp) library adapted for the Mirage namespace.\n\n* [lib/cow/](http://github.com/avsm/mirage/tree/master/lib/cow/) is the Caml-on-the-Web library, with support for common Internet markup formats such as HTML, XML, CSS, Atom and Markdown. It uses the superb [Xmlm](http://erratique.ch/software/xmlm/doc/Xmlm) library by Daniel Bunzli, as well as a series of syntax extensions described more fully [here](/wiki/cow).\n\n!!!Runtime\n\nAll of that nice OCaml code in `lib/` also calls a number of `external` functions that must be present in the final binary for the link phase to succeed. These runtimes are either compiled in directly (in the case of Xen), or linked to the host runtime (in the case of UNIX, where OCaml will be installed).\n\n* [lib/os/runtime_xen/](http://github.com/avsm/mirage/tree/master/lib/os/runtime_xen) compiles into a full Xen OS, and so provides the minimal set of C libraries required to run the OCaml runtime directy in a VM. Note that this is currently fatter than it needs to be, as [dietlibc](http://www.fefe.de/dietlibc/) is present at the moment but is largely redundant and will be removed soon. The interesting bits to browse through are in [lib/os/runtime_xen/kernel/](http://github.com/avsm/mirage/tree/master/lib/os/runtime_xen/kernel) which is the mini-operating system core.\n\n* [lib/os/runtime_unix/](http://github.com/avsm/mirage/tree/master/lib/os/runtime_unix) should be familiar to anyone who has built UNIX foreign-function bindings before. It links Mirage applications as native code ELF binaries. It uses [libev](http://software.schmorp.de/pkg/libev.html) to provide high-performance event support, and also provides bindings to both `tuntap` (for the Ethernet device driver) and sockets (for the Flow module).\n\n* [lib/os/runtime_node/](http://github.com/avsm/mirage/tree/master/lib/os/runtime_node) maps an application onto Node.JS.  This one is an experimental, but very fun backend to play with (see [this discussion](https://github.com/dsheets/ocamljs/commit/7bb091f306c93f70bf6e70fe481a38efd71dda5b) for just how weird Javascript integers are).\n\n" ]
 | "wiki/talks.md" | "/wiki/talks.md" -> Some ["This page links to various technical talks and slide decks on Mirage.\n\n!!Videos\n\n!!!LinkedIn\n\n[Alex Feinberg](http://twitter.com/strlen) kindly hosted a Mirage talk at [LinkedIn](http://linkedin.com)'s Search Networks and Analytics Team ([blog](http://sna-projects.com/blog/2010/10/mirage/)).\n\n<iframe src=\"http://player.vimeo.com/video/16189862\" width=\"400\" height=\"225\" frameborder=\"0\">&nbsp; </iframe>\n<p><a href=\"http://vimeo.com/16189862\">LinkedIn Tech Talk</a> by <a href=\"http://anil.recoil.org/\">Anil Madhavapeddy</a></p>\n\n!!!ICFP\n\nThis was a report delivered at ICFP 2010 about our experiences with using OCaml in the Xen management toolstack. \nNot directly Mirage-related, but much of the inspiration for trying out OCaml in a microkernel environment came out of this work.\nThe [video](http://portal.acm.org/citation.cfm?id=1863557) is unfortunately only available behind the ACM paywall, but the paper can be found [here](/wiki/papers).\n\n!!Slides\n\n!!!ML Workshop 2010\n\n<div style=\"width:425px\" id=\"__ss_5291651\"> <strong style=\"display:block;margin:12px 0 4px\"><a href=\"http://www.slideshare.net/AnilMadhavapeddy/mirage-ml-kernels-in-the-cloud-ml-workshop-2010\" title=\"Mirage: ML kernels in the cloud (ML Workshop 2010)\">Mirage: ML kernels in the cloud (ML Workshop 2010)</a></strong> <iframe src=\"http://www.slideshare.net/slideshow/embed_code/5291651?rel=0\" width=\"425\" height=\"355\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\">&nbsp; </iframe></div>\n" ]
 | "wiki/tutorial-lwt.md" | "/wiki/tutorial-lwt.md" -> Some ["[Lwt](http://www.ocsigen.org/lwt) is a lightweight cooperative\nthreading library for OCaml. A good way to understand Lwt and its use\nin Mirage is to write some simple code. This document introduces the\nbasic concepts and suggests programs to write.  Note that Lwt has a\nnumber of syntax extensions that are widely used in Mirage. These are\nintroduced as you go along through the tutorial.\n\n\n!!Tutorial\n\nThe full Lwt manual is available\n[elsewhere](http://ocsigen.org/lwt/manual/), but the minimal stuff\nneeded to get started is here.  The first useful function is the\n`return` statement, which constructs a constant thread:\n\n```\n  val return: 'a -> 'a Lwt.t\n```\n\nIt is used to contruct a thread that immediately returns with the\nprovided value.  Once the value is wrapped in an Lwt thread, it cannot\ndirectly be used (as the thread may not have completed yet).  This is\nwhere `bind` comes in:\n\n```\n  val bind: 'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t\n```\n\n`bind t f` creates a thread which waits for `t` to terminate, then\npasses the result to `f`. If `t` is a sleeping thread, then `bind t f`\nwill be a sleeping thread too, until `t` terminates. If `t` fails,\nthen the resulting thread will fail with the same exception.\n\nThere are two important operations to compose threads: `join` and `choose`.\n\n```\n  val join : unit Lwt.t list -> unit Lwt.t\n```\n\n`join` takes a list of threads and waits for all of them to terminate.\nIf at least one thread fails then `join l` will fail with the\nsame exception as the first to fail, after all threads terminate.\n\n```\n val choose : 'a t list -> 'a t\n```\n\n`choose l` behaves as the first thread in l to terminate. If several\nthreads are already terminated, one is chosen at random.\n\nThe infix operators `<&>` and `<?>` are defined in the `Lwt` module, where\n `a <&> b` is equivalent to `join [a; b]`, and\n `a <?> b` is equivalent to `choose [a; b]`.\n\n!!Sleep and join\n\n!!!Challenge\n\nNow write a program that spins off two threads, each of which sleep\nfor some amount of time, say 1 and 2 seconds and then one prints\n\"Heads\", the other \"Tails\".  After both have finished, it prints\n\"Finished\" and exits.  To sleep for some time use `OS.Time.sleep` and\nto print to console use `OS.Console.log`.  Note that `OS` is a\nMirage-specific module, if you are using `Lwt` in another context, use\n`Lwt_unix.sleep` and `Lwt_io.write`.\n\nYou will need to have Mirage [installed](/install) and the script\n`mir-build` available in your search path.  Create a file `foo.ml`\nwith the following content and edit it:\n\n```\n  open Lwt\n  open OS\n\n  let main () =\n      (* the guts go here *)\n```\n\n\nTo compile the application, execute `mir-build unix-socket/foo.bin`.\n\nYou can now run your example by executing the\n`_build/unix-socket/foo.bin` file.\n\nThe build system will automatically figure out all the dependencies\nrequired, so you do not need to specify them manually.  It will also\nautomatically create a project file called `foo.mir` and in it it will\nput the default entry point of the program in the form\n`Module.function`:\n\n```\n  Foo.main\n```\n\nIf however a different entry point (not `main`) is to be used then it\nhas to be explicitly specified.  This is done by putting the entry\npoint in the required form in a `.mir` file, say `bar.mir`.  To\ncompile the application, execute `mir-build unix-socket/bar.bin`.\n\n\n!!!Solution\n\n```\n  open Lwt (* provides bind and join *)\n  open OS  (* provides Time, Console and Main *)\n\n  let main () =\n    bind (join [\n      bind (Time.sleep 1.0) (fun () ->\n        Console.log \"Heads\"; return ()\n      );\n      bind (Time.sleep 2.0) (fun () ->\n        Console.log \"Tails\"; return ()\n      );\n    ]) (fun () ->\n      Console.log (\"Finished\"); return ()\n    )\n```\n\nThis is `regress/lwt/heads1.ml` in the Mirage code repository.\n\n!!!Syntax Extensions\n\nUsing Lwt does sometimes require significantly restructuring code, and\nin particular doesn't work with many of the more imperative OCaml\ncontrol structures such as `for` and `while`.  Luckily, Lwt includes a\ncomprehensive [pa_lwt](http://ocsigen.org/lwt/api/Pa_lwt) syntax\nextension that makes writing th";
"readed code as convenient as vanilla\nOCaml.  Mirage includes this extension by default, so you can use it\nanywhere you want.\n\nThis is a good place to introduce some of these extensions.  When\nopening the `Lwt` module, the infix operator `>>=` is made available.\nThis operator is an alternative to the `bind` function and often makes\nthe code more readable. E.g. consider `bind (bind (bind t f) g) h` and\nthe operator based equivalent expression `t >>= f >>= g >>= h`.  We\ncan now rewrite the previous solution more simply:\n\n```\n  open Lwt (* provides >>= and join *)\n  open OS  (* provides Time, Console and Main *)\n\n  let main () =\n    join [\n      (Time.sleep 1.0 >>= fun () -> (Console.log \"Heads\"; return ()));\n      (Time.sleep 2.0 >>= fun () -> (Console.log \"Tails\"; return ()));\n     ] >>= fun () ->\n       Console.log \"Finished\";\n       return ()\n```\nThis is `regress/lwt/heads2.ml` in the Mirage code repository.\n\n\n!!!Anonymous Bind\n\nIf you are chaining sequences of blocking I/O, a common pattern is to write:\n\n```\n  write stdio \"Foo\" >>= fun () ->\n  write stdio \"Bar\" >>= fun () ->\n  write stdio \"Done\"\n```\n\nYou can replace these anonymous binds with the `>>` operator instead:\n\n```\n  write stdio \"Foo\" >>\n  write stdio \"Bar\" >>\n  write stdio \"Done\"\n```\n\n!!!Lwt Bindings\n\nThe binding operation reverses the normal `let` binding by specifying the name\nof the bound variable in the second argument. Consider the thread:\n\n```\n  e1 >>= fun x -> e2\n```\n\nHere, we wait for the result of `e1`, bind the result to `x` and\ncontinue into `e2`.  You can replace this with the more natural `lwt`\nsyntax to act as a \"blocking let\":\n\n```\n  lwt x = e1 in\n  e2\n```\n\nNow, the code looks like just normal OCaml code, except that we\nsubstitute `lwt` for `let`, with the effect that the call blocks until\nthe result of that thread is available.  Lets revisit our heads and\ntails example from above and see how it looks when rewritten with\nthese syntax extensions:\n\n```\n  open Lwt\n  open OS\n\n  let main () =\n    let heads =\n      Time.sleep 1.0 >>\n      return (Console.log \"Heads\");\n    in\n    let tails =\n      Time.sleep 2.0 >>\n      return (Console.log \"Tails\");\n    in\n    lwt () = heads <&> tails in\n    Console.log \"Finished\";\n    return ()\n```\n\nThis is `regress/lwt/heads_syntax.ml` in the Mirage code repository.\n\nHere we define two threads, `heads` and `tails`, and block until they\nare both complete (via the `lwt ()` and the `<&>` join operator).  If\nyou want to print \"Finished\" before the previous threads are complete,\njust put the print statement (`Console.log`) before the join statement\n(`... <&> ...`).\n\n\n!!Cancelling\n\nIn order to cancel a thread, the function `cancel` (provided by the\nmodule `Lwt`) is needed. It has type `'a t -> unit` and does exactly\nwhat it says (except on certain complicated cases that are not in the\nscope of this tutorial).  A simple timeout function that cancels a\nthread after a given number of seconds can be written easily:\n\n```\n  (* In this examples and all those afterwards, we consider Lwt and OS to be opened *)\n  let timeout f t =\n    Time.sleep f >>= fun () -> cancel t\n```\n\n!!!Challenge\n\nThis `timeout` function does not allow one to use the result returned\nby the thread `t`.\n\nModify the `timeout` function so that it returns either `None` if `t`\nhas not yet returned after `f` seconds or `Some v` if `t` returns `v`\nwithin `f` seconds.  In order to achieve this behaviour it is possible\nto use the function `state` that, given a thread, returns the state it\nis in, either `Sleep`, `Return` or `Fail`.\n\n!!!Solution\n\n```\n  let timeout f t =\n    Time.sleep f >>\n    match state t with \n    | Return v -> return (Some v)\n    | _        -> cancel t; return None\n```\n\nThis is used in `regress/lwt/timeout1.ml` in the Mirage code\nrepository.\n\n\nDoes your solution match the one given here and always returns after\n`f` seconds, even when `t` returns within `f` seconds?\n\nThis is a good place to introduce a third operation to compose\nthreads: `pick`.\n\n```\n val pick : 'a t list -> 'a t\n```\n\n`pick` behaves exactly like `choose` except that it cancels all other\nsleeping thre";
"ads when one terminates.\n\n\n!!!Challenge\n\nIn a typical use of a timeout, if `t` returns before the timeout has\nexpired, one would want the timeout to be cancelled right away.  The\nnext challenge is to modify the timeout function to return `Some v`\nright after `t` returns.  Of course if the timeout does expire then it\nshould cancel `t` and return `None`.\n\nIn order to test your solution, you can compile it to a mirage\nexecutable and run it using the skeleton provided for the first\nchallenge.\n\n\n!!!Solution\n\n```\n  let timeout f t =\n    let tmout = Time.sleep f in\n    pick [\n      (tmout >>= fun () -> return None);\n      (t >>= fun v -> return (Some v));\n    ]\n```\nThis is in `regress/lwt/timeout2.ml` in the Mirage code\nrepository.\n\n\n!!A Pipe example\n\n!!!Challenge\n\nWrite an echo server, reading from a dummy input generator and, for\neach line it reads, writing it to the console. The server should never\nstop listening to the dummy input generator. Here is a basic dummy\ninput generator:\n\n```\n  let read_line () =\n    OS.Time.sleep (Random.float 2.5) >>\n    Lwt.return (String.make (Random.int 20) 'a')\n```\n\n!!!Solution\n\n```\n  let rec echo_server () =\n    lwt s = read_line () in\n    Console.log s;\n    echo_server ()\n```\n\nThis is in `regress/lwt/echoserver1.ml` in the Mirage code\nrepository.\n\n\n\n!!Using Mailboxes\n\nAmong the different modules the Lwt library provides is\n`Lwt_mvar`. This module eases inter-thread communication. Any thread\ncan place a value in a mailbox using the `put` function; dually, the\n`take` function removes a value from a mailbox and returns\nit. `take`'s type, `'a Lwt_mvar.t -> 'a Lwt.t`, indicates that a call\nto the function may block (and let other threads run). The function\nactually returns only when a value is available in the mailbox.\n\nHere are the needed functions from the `Lwt_mvar` module:\n\n```  \n  (* type of a mailbox variable *)\n  type 'a t\n\n  (* creates a new empty mailbox variable *)\n  val create_empty : unit -> 'a t\n\n  (* puts a value into a mailbox variable, and blocks if it is full *)\n  val put : 'a t -> 'a -> unit Lwt.t\n\n  (* will take any available value and block if the mailbox is empty *)\n  val take : 'a t -> 'a Lwt.t \n```\n\n!!!Challenge\n\nWrite a small set of functions to help do pipeline parallelism. The\ninterface to be implemented is the following (names should give away\nthe appropriate semantic):\n\n```\n  val map: ('a -> 'b Lwt.t) -> 'a Lwt_mvar.t -> 'b Lwt_mvar.t\n  val split : ('a * 'b) Lwt_mvar.t -> 'a Lwt_mvar.t * 'b Lwt_mvar.t\n  val filter: ('a -> bool Lwt.t) -> 'a Lwt_mvar.t -> 'a Lwt_mvar.t\n```\n\n!!! Solution\n\n```\n  let map f m_in =\n    let m_out = Lwt_mvar.create_empty () in\n    let rec map_h () =\n      Lwt_mvar.take m_in   >>=\n      f                    >>= fun v ->\n      Lwt_mvar.put m_out v >>\n      map_h ()\n    in\n    let t = map_h () in\n    m_out\n\n\n  let split mab =\n    let ma = Lwt_mvar.create_empty () in\n    let mb = Lwt_mvar.create_empty () in\n    let rec split_h () =\n      Lwt_mvar.take mab >>= fun (va, vb) ->\n      Lwt.join [\n          Lwt_mvar.put ma va;\n          Lwt_mvar.put mb vb;\n        ]               >>\n      split_h ()\n    in\n    let t = split_h () in\n    (ma, mb)\n\n\n  let filter f m_in =\n    let m_out = Lwt_mvar.create_empty () in\n    let rec filter_h () =\n      Lwt_mvar.take m_in >>= fun v ->\n      f v                >>= function\n      | true -> (Lwt_mvar.put m_out v >>\n                 filter_h ())\n      | false -> filter_h ()\n    in\n    let t = filter_h () in\n    m_out\n```\n\nNote that in each of the above a recursive Lwt thread is created and\nwill run forever.  However, if the pipline ever needs to be torn down\nthen this recusive thread should be cancelled.  This can be done by\nmodifying the above funtions to also return the `'t Lwt.t` returned by\n`map_h`, `split_h` and `filter_h`, which can then be cancelled when\nrequired.\n\n\n\n!!!Challenge\n\nUsing the pipelining helpers, change the echo server into a string\nprocessing server. The new version should output each line of text\nuppercased (`String.uppercase` can help) after waiting for `l` seconds\nwhere `l` is the length of the string.\n\n!";
"!!Solution\n\n```\n  let read_line () =\n    Lwt.return (String.make (Random.int 20) 'a')\n\n  let wait_strlen str =\n    OS.Time.sleep (float_of_int (String.length str)) >>\n    Lwt.return str\n\n  let cap_str str =\n    Lwt.return (String.uppercase str)\n\n  let rec print_mvar m =\n    lwt s = Lwt_mvar.take m in\n    Console.log s;\n    print_mvar m\n\n  let ( |> ) x f = f x\n\n  let echo_server () =\n    (*define mailboxes*)\n    let m_input = create_empty () in\n    let m_output =\n      m_input |> map wait str_length |> map cap_str\n    in\n    (*define loops*)\n    let rec read () =\n      read_line ()             >>= fun s ->\n      Lwt_mvar.put m_input str >>=\n      feed\n    in\n    let rec write () =\n      Lwt_mvar.take m_output >>= fun r ->\n      Console.log r;\n      write ()\n    in\n    (*starts loops*)\n    (read ()) <&> (write ())\n```\n\nThis is in `regress/lwt/echoserver2.ml` in the Mirage code\nrepository.\n\n\n!!!Challenge\n\nTo exercise all the pipelining helpers, set up an integer processing\nserver with the following stages:\n\nEvery second write a tupple containing a pair of small random integers\n`(Random.int 1000, Random.int 1000)` into a mailbox.  Process it\nthrough a stage that produces a tupple containing the sum and the\nproduct of the input integers, `split` the tupple into two mvars and\nfor each of the mvars insert a stage that simply prints the value and\nthen puts it to an output mvar.  Next insert a filter stage that only\nlets odd numbers through.  Finally add a stage that prints the word\n\"Odd\" if anything reaches it.\n\n\n!!!Solution\n\n```\n  let add_mult (a, b) =\n    return (a + b, a * b)\n\n  let print_and_go str a =\n    Console.log (Printf.sprintf \"%s %d\" str a);\n    return a\n\n  let test_odd a =\n    return (1 = (a mod 2))\n\n  let rec print_odd m =\n    lwt a = Lwt_mvar.take m in\n    Console.log (Printf.sprintf \"Odd: %d\" a);\n    print_odd m\n\n  let ( |> ) x f = f x\n\n  let int_server () =\n    let m_input = Lwt_mvar.create_empty () in\n    let (ma, mm) = m_input |> map add_mult |> split in\n    let _ = ma |> map (print_and_go \"Add:\") |> filter test_odd |> print_odd in\n    let _ = mm |> map (print_and_go \"Mult:\") |> filter test_odd |> print_odd in\n    let rec inp () =\n      Lwt_mvar.put m_input (Random.int 1000, Random.int 1000) >>\n      Time.sleep 1. >>\n      inp () in\n    inp ()\n```\n\nThis is in `regress/lwt/intserver.ml` in the Mirage code repository.\n\n\n!!Stream Processing\n\nThe pipelining challenges of the previous section uses mailboxes provided by the\n`Lwt_mvar` module. One of the feature of such values is that no more than one\nmessage can be deposited in the mailbox. This is made obvious by the return type\nof `Lwr_mvar.put` being in `Lwt.t`. This provides a natural throttle mechanism\nto our pipeline. However, in specific cases, such a throttle is superfluous.\n\nUsing the `Lwt_stream` module, one can devise a different pipeline with a\ngreedier processing scheme. Several functions can be used to create a stream,\nall of them can be defined via:\n\n```\n  val create : unit -> 'a t * ('a option -> unit)\n```\n\nThe `create` function returns a stream and a push function. The push function is\nthe only available way to add content to the stream. Pushing `None` will close\nthe stream, while pushing `Some x` will make `x` available in the stream.\n\nThere are several ways to read from a stream. The most direct one being\n\n```\n  val get : 'a t -> 'a option Lwt.t\n```\n\n`get s` returns either `Some x` when `x` is available (which may be right away)\nor `None` when stream is closed. Order of elements in streams is preserved,\nmeaning that elements are pulled in the order they are pushed.\n\n!!!Challenge\n\nWrite the same pipelining library as in the mailbox challenge, replacing\ninstances of `Lwt_mvar.t` by `Lwt_stream.t`:\n\n```\n  val map: ('a -> 'b Lwt.t) -> 'a Lwt_stream.t -> 'b Lwt_stream.t\n  val split : ('a * 'b) Lwt_stream.t -> 'a Lwt_stream.t * 'b Lwt_stream.t\n  val filter: ('a -> bool Lwt.t) -> 'a Lwt_stream.t -> 'a Lwt_stream.t\n```\n\n!!!Solution\n\n```\n  let map f source =\n    let (s, push) = Lwt_stream.create () in\n    let rec aux () = match_lwt Lwt_stream.get source with\n      | ";
"None -> push None; return ()\n      | Some x -> lwt y = f x in push (Some y); aux ()\n    in\n    let _ = aux () in\n    s\n\n  let split source =\n    let (s1, push1) = Lwt_stream.create () in\n    let (s2, push2) = Lwt_stream.create () in\n    let rec aux () = match_lwt Lwt_stream.get source with\n      | None -> push1 None; push2 None; return ()\n      | Some (x,y) -> push1 (Some x); push2 (Some y); aux ()\n    in\n    let _ = aux () in\n    (s1, s2)\n\n  let filter f source =\n    let (s, push) = Lwt_stream.create () in\n    let rec aux () = match_lwt Lwt_stream.get source with\n      | None -> push None; return ()\n      | Some x -> match_lwt f x with\n        | true -> push (Some x); aux ()\n        | false -> aux ()\n    in\n    let _ = aux () in\n    s\n```\n\nNotice, in the provided solution, the usage of `f` in `map`: only when `f`\nreturns does the next element is polled and treated. (The same remark applies to\n`filter`.) This means that the elements of the stream are processed serially.\n\nThe `Lwt_stream` library actually provides a number of processing functions.\nSome functions are suffixed with `_s` meaning that they operate sequentially\nover the elements, other with `_p` meaning that they operate in parallel over\nthe elements. The module `Lwt_list` uses the same suffixing policy.\n\n\n\n\n!!Mutexes and cooperation\n\nWith Lwt, it is often possible to avoid mutexes altogether! The web\nserver from the [Ocsigen](http://ocsigen.org) project uses only two,\nand the Mirage source code none. In usual concurrent systems, mutexes\nare used to prevent two (or more) threads executing concurrently on a\ngiven piece of data. This can happen when a thread is preemptively\ninterrupted and another one starts running. In Lwt, a thread executes\nserially until it explicitly yields (most commonly via `bind`); for\nthis reason, Lwt threads are said to be\n[cooperative](http://en.wikipedia.org/wiki/Cooperative_multitasking#Cooperative_multitasking.2Ftime-sharing).\n\nFrom the coder's perspective, it means that the evaluation of expressions\nwithout the `Lwt.t` type will *never* go through the thread scheduler. Note however,\nthat it is possible to switch threads without executing the scheduler via the\n`wakeup` function.\nThis instead of surrounding an expression with `lock` and `unlock` statements, one can simply enforce that the type\nof the expression is not `Lwt.t` and check for the absence of calls to `wakeup`.\nFinally, be aware that some functions from the `Lwt` standard libraries do use thread switching.\n\nThe obvious danger associated with cooperative threading is having threads not\ncooperating: if an expression takes a lot of time to compute with no\ncooperation point, then the whole program hangs. The `Lwt.yield`\nfunction introduces an explicit cooperation point. `sleep`ing also\nobviously makes the thread cooperate.\n\nIf locking a data structure is still needed between yield points, the\n`Lwt_mutex` module provides the necessary functions. To obtain more information\non thread switching (and how to prevent it) read the `Lwt` mailing list archive:\n[Lwt_stream, thread switch within push function](https://sympa.mancoosi.univ-paris-diderot.fr/wws/arc/ocsigen/2011-09/msg00029.html)\nwhich continues\n[here](https://sympa.mancoosi.univ-paris-diderot.fr/wws/arc/ocsigen/2011-10/msg00001.html).\n\n!!Exceptions and Try/Catch\n\nOne very, very important thing to remember with cooperative threading\nis that raising exceptions is not safe to do between yield points.  In\ngeneral, you should never call `raise` directly. Lwt provides an\nalternative syntax:\n\n```\n  exception Foo\n  let main () =\n    try_lwt\n      let x = ... in\n      raise_lwt Foo\n    with\n      |Foo -> return (Console.log \"Foo raised\")\n```\n\nThis looks similar to normal OCaml code, except that the caught\nexception has an `Lwt.t` return type appended to it.\n\n!!Control Flow\n\nLwt also provides equivalents of `for` and `while` that block on each\niteration, saving you the trouble of rewriting the code to use `bind`\nrecursively.  Just use `for_lwt` and `while_lwt` instead; for example:\n\n```\n  for_lwt i = 0 to 10 do\n    OS.Time.sleep (float_o";
"f_int i) >>\n    return (OS.Console.log \"foo\")\n  done\n```\n\nThere is also a `match_lwt` which will bind the result of a thread and\nimmediately pattern-match on its value.  Thus, the two fragments of\ncode are equivalent:\n\n```\n  let e1 >>= function\n  |true -> ...\n  |false -> ...\n```\n\n```\n  match_lwt e1 with\n  |true -> ...\n  |false -> ...\n```\n\n!!How does it work\n\nUnderstanding the basic principles behind `Lwt` can be helpful.\n\nThe core of Lwt is based on an event loop. In \"standard\" (non-Mirage)\nsettings, this loop is started using the `Lwt_main.run` function, However,\nwhen using Mirage, the loop is automatically started using the program's\nentry point (as specified in the optional `.mir` file).\n\nBecause it's based on an event loop, threads are actually very cheap in Lwt.\n(Hence the name.) Sleeping actually registers an event that will wake up the\nassociated thread when possible. Depending on the backend, the event\nregistering slightly differs.\n\n\n" ]
 | "wiki/weekly/2013-04-16.md" | "/wiki/weekly/2013-04-16.md" -> Some ["16th April 2013: release, libvirt and Mirari\n\n!! Agenda\n\n* Anil Madhavapeddy: overview of release goals\n* Dave Scott: libvirt and other status\n* Vincent Bernardoff: Mirari and testing\n* Thomas Gazagnaire: Irminsule, the storage substrate for Mirage\n* Amir Chaudhry: xen.org incubation status and next steps\n\n*Attendees:* Thomas Gazagnaire, Vincent Bernardoff, Jonathan Ludlam, David\nSheets, David Scott, Anil Madhavapeddy, Amir Chaudhry, Prashanth Mundkur\n\n!! Minutes\n\n!!! Overview of release goals (Anil)\n\nAim of this meeting is to clarify release goals for 1.0. We're aiming for the\nOSCON 2013 talk in July, so release plan should have a stable output by June \nso that we can document and stabilise.  Three concrete applications:\n\n* Need stub-domains for Xenstore and Xenconsoled.  Device drivers (mainly\nnetfront and blkfront) should compile on both Xen and Linux to let us\nswap between front-ends and back-ends as either stub-domain or dom0.\n\n* Self-hosting website and DNS server. Already working well now, but the\nTCP stack could use some attention, as well as an SSL prototype.\n\n* Proof of concept of distributed system (ideally can be demo'd for OSCON).\nSome strawman distributed system to start with; current thinking is something\nlike OCamlot or Signpost.  This would be a nice \"Hello world!\" demo as it\nrequires actors, a persistent job queue. For example, i.e spawning new VMs in\nresponse to load, as evidenced by self-scaling web-server.\n\nDavid Sheets (working on OCamlot), asks about the place for Mirage in OCamllot.\nFor example would it be the dispatcher running as a Mirage kernel on \"the\ncloud\" and the workers would be running as ordinary VMs? This would demonstrate\nthat the distributed system actually works. Anil: can discuss the details of\nthis later (e.g what OS are the workers using), but that's correct in\nprinciple.  We need to split the `OS` module into a controller that is\nresponsible for resource provisioning, and the worker application itself.\nVincent is already working on this on the UNIX backend.\n\n!!! Libvirt and other cloud APIs (Dave)\n\nDave: Libvirt manages VMs on a physical host and is hypervisor-agnostic.  OCaml\nbindings exist for this via Richard Jones at Red Hat, and Dave Scott has been\nfixing up the Xen bindings.  We can't use it to work with EC2 or proprietary\nclouds (have to use EC2 API directly there), but we could write something that\nsits between if really motivated. libvirt could work with KVM and other\nmachines, which is a big plus when we have other hypervisor backends such as\nKVM.\n\nAnil: Need to investigate mapping to cloud APIs; e.g Mirage app splits into the\ncontroller and the app that does worker as a separate VM (on Xen), or a\nseparate process (on UNIX), or even uses capability APIs such as Capsicum on\nFreeBSD to separate the two.\n\nNo current fork API on Xen: that is, a VM cannot self-provision more\nresources, hence the need for this controller/worker split.  This is a general\nissue on the cloud, and there are several ad-hoc PV interfaces (e.g. balloon\ndriver).  We need to think about how the OS library interface for Mirage will\ndo in this space.\n\n*Decision:* Initial cloud APIs to target are libvirt (will cover 90% of FOSS\nusers as it works with `xm`) and EC2 (interesting demos and for self-hosting\nwebsite).\n\nDave: Need to make sure that libvirt works on Ubuntu and Debian.\n\nJon: asks whether configuration is still a compile-time thing.  Can also do \nkey exchange thing at compile time, which should be cool and avoids dynamic \nsecret exchange.  Anil: yes, and closely tied into Mirari (see next).\n\n!!! Mirari (Vincent)\n\nMirari splits workflow into config stage (`mirari configure`) which installs\nOPAM dependencies, the build phase which invokes obuild, and mirari run to\nexecute the result.  The configure and build phases work fine, but we're\nmissing mirari `run` to interface with libvirt and EC2.\n\nNeed to think about the FRP model for configuring and keeping track of\ndependencies.  It would make an awesome demo (and useful in general!) to\nreconfigure server variables and recompile/launch precisely what ";
"is needed.\nQuestion asked if anyone has used FRP for anything serious.  Silence ensues.\nFollowed by some sniggering. Followed by serious looks.  Mort's name is mentioned.\n\nPrashanth: Does Mirari monitor VMs across multiple hosts? \nAnil: Eventually yes, but not in 1.0. It keeps track of local VMs for now on\nthe same host and Mirari v2 will deal with tracking versions \nacross hosts, or on EC2.  Just libvirt for now will get us a long way in\nterms of usability.\n\nJon: we need to define some goal applications for Mirage 2.0 to make all these\ndesign decisions clearer.  Anil agrees, and suggests:\n\n1. Project Windsor, a dom0 free system that essentially turns xapi into a\ncommunicating set of unikernels.\n\n2. For Mirage website, e.g automatically reconfiguring itself from \nindividual to two VMs and a load balancer, and then more VMs and DNS \nbalancing as load increases.  This is the concept of self-scaling.   How do \nwe do this in the libraries?  Anil would love to demo a self-scaling webserver at \nOSCON: Mort, Anil and Malte have played with this a couple of years ago, but its\nnot practical at the VM level without fast boots (which we have now) and careful\ndependency tracking across resources and libraries.\nThe latency and precision we can bring is an order of magnitude better than the\ncurrent state-of-the-art, and (thanks to Dave's work on xenopsd), we have the control\nstacks to glue them all together.\n\nJon: XenServer pool-level support for these makes sense since there is already\na cluster-wide API to deal with moving across hosts.\nAnil: yes, but the XAPI distributed db is a potential significant slowdown.\n\n!!! Irminsule (Thomas)\n\nWe need a storage interface (persistence) and control interface in Mirage.  \nBranch-consistency is the lowest level we can work at without embedding\nany policy in the database.  Want to have a DB that grows immutably, and then we just have a \ngarbage collection problem to deal with (\"just\").\n\nGoal is to have a Mirage-friendly DB with 3 scenarios:\n\n1. VM storage:  expose an NFS library and eventually PV blkfront that can\nexpose fake git directory to VM.  Not stuck at the block-level but real\nfilesystem-level packs.\n\n2. Native Mirage filestore system. Needs to be lock-free as they have to run \nall over the public cloud.  Irminsule designed for this.  Could use Sqlite\nwith data constraints but... no. Desire a more rigorous, low-level DB and\nbuild SQL on top as necessary.\n\n3. For the RWO book, people making comments have lost stuff as Javascript\nAPI requires people to be online to report issues.\nWe can compile Irminsule down into JS and then comments can be made \nlocally and then sync/merged upstream.  \n\nJon: asked if you need the whole blob/tree in your browser to do the stuff\nfor RWO book?\nAnil/Thomas: you need the graph but not the whole thing as we're not stuck to\nonly needing the git protocol. The low-level protocol actually supports lazy\ngraph traversal fine.  Anil: we can also rebase the trunk using a sliding\nwindow scheme.\n\nJon: Targeting Xenstore may be worth considering as its a close fit to\nIrminsule. Thomas points out that very close mappings between existing\ntransaction semantics and Xenstore (Thomas worked on both).  Anil: we can\nalso turn Xenstore into a cluster-wide persistent store like this, removing\na lot of XAPI complexity.\n\nPrashanth: what if I want something from the subdirectory rather than root? \nThomas: Git doesn't allow this but in his implementation its possible by\ndelving at a lower level. Sheets: Git patches have been proposed but\nrejected that permit this in git for submodules.\n\n\n!!! Xenproject update (Amir)\n\nXen.org has become a Linux Foundation project (called Xen project) and there \nhave been some high profile announcements so far which explicitly mention \nMirage OS so we can expect more attention being paid to the work.  There \nwill also be blog posts and news about Mirage being put up on Xen Project's \nsite and openmirage.org.\n\nAnil: we all need to be looking over the installation instructions and \nchecking they work ok. They need refreshing and tweaking as even small\nmi";
"ssing steps cause confusion.\n\n!!! Any other business\n\nJon wanted get Mirage set up as a test VM for XAPI. It does a great job\n(starts and stops in no time), which is part of motivation to get start-\nsuspend working properly.  Anil: fuzz-testing in general is a \ngood thing and we can use this in all the libraries.  Balraj created a\nTCP loopback VM that uses two VIFs in single VM (see mirage-skeleton/tcp).\n\nPlan for next week's call: Discuss the mirari FRP integration in more detail.\nInvite Daniel Bunzli to advise.\n" ]
 | "wiki/weekly/2013-04-23.md" | "/wiki/weekly/2013-04-23.md" -> Some ["23th April 2013: Irminsule, concurrent revisions and release checklist\n\n!! Agenda\n\n* Thomas Gazagnaire: [Irminsule](http://www.cl.cam.ac.uk/projects/ocamllabs/tasks/t2.html#Irminsule) demonstration\n* Richard Mortier: [Concurrent revisions](http://research.microsoft.com/en-us/projects/revisions/) implementation in OCaml\n* Anil Madhavapeddy: [Release checklist](/wiki/dev-preview-checklist) review\n\n*Attendees*: Anil Madhavapeddy, Dave Scott, Vincent Bernardoff, Thomas Gazagnaire, Richard Mortier, Daniel Bünzli, Prashanth Mundkur.\n\n!! Irminsule Early Demo\n\nWe managed to get screen-sharing working from Dave's iPad, with pinch-to-zoom\nmaxing the screen-size and everyone realising that we are living in the\nfuture!  Thomas walked us through the Irminsule interfaces, available on [Github](https://github.com/samoht/irminsule).\nIrminsule has three parts, discussed in more detail below: a low-level immutable collection of binary blobs, some structured\nobjects and revision-branching structure.\n\n!!! Low-level immutable database\n\nWhen you write a value, you get a key (SHA1 or SHA256?). You can read the value\nwith a key, if you don't have a key you get a null.  This is non-blocking.  \n\n!!! Structured objects\n\nOn top of immutable DB you have some structured objects, like trees. If you\ngive a root and hash, it'll give you back some key. \n\n*Anil:* how come the `merge` function maps a `value` to `value` and not `tree` to `tree`?\nConversation discussing the type of the `merge` function, and how higher level\nabstractions could be built on top of it.  More design work needed to ensure\nthat existing git merge strategies can be implemented using it.\n\n*Anil:* Can Irminsule replace Xenstore with a persistent version?\nConsensus is this should be easy once Dave finishes his xenstore refactoring to\nisolate the database, and careful encoding of existing transaction semantics\ninto Irminsule (which Thomas is familiar with as he did lots of work on\nXenstore).  Dave Scott agrees with this assessment and thinks a distributed xenstore isnt too bad.\n\n*Prashanth:* What about traversal order in the tree? would it make sense to have specified order of traversal?\nAnswer: there is a stable order, but in the future we may want to define\niterators instead of creating lots of temporary list. This is just an\nallocation optimisation and not important for version 1.\n\n!!! Revision Structure\n\nOn top of structured objects, you have a revision structure.  Read [Git from the Bottom Up](http://ftp.newartisans.com/pub/git.from.bottom.up.pdf) for a design perspective on this. Tags are the only mutable structure, and annotated tags create objects with tags associated with them.  Thomas started to work on (only two days) how to sync between two repositories via a pull/push model, and begin to model existing concurrency models on top of the branch-consistent model exposed by Irminsule.\n\n*Anil:* How do you construct a remote node?\n*Thomas:* right now the module types are kept abstract deliberately, but the implementation provides a constructor function (e.g. TCP).\n\n*Anil:* Sounds like this almost ready for David Sheets to pick up and have a look at for OCamlot.  We only need basic stuff for OCamlot and could build simple queues on top of this.  Is persistence like the git file format?   Thomas: yes, see [samoht/cagit](http://github.com/samoht/cagit) for the pure-OCaml git library.\n\n*Prashanth:* What is the list of labels in the TREE.set function for?\n*Answer:* the label list is the list of path fragments in the DAG, analogous to a filename under UNIX.\n\n*Anil:* points out a typo in the `let` in TG's code.  The world breaths a sigh of relief.\n\n!! Concurrent revisions\n\nMort spoke about [froctal](http://github.com/mor1/froctal), which is a wrapper to track configuration dependencies in Mirage code. See his [README](https://github.com/mor1/froctal) for thoughts so far.\nHe first looked at [ocaml-md](https://github.com/avsm/ocaml-ld) which was toy experiment last summer to track reconfiguration and then tried Jake Donham's [Froc](http://github.com/jaked/froc) library during ASPLOS.  The";
"n he was thinking about what we could use FRP for in Mirage. Self-scaling web services doesn't necessarily seem to need FRP, but just simpler configuration tracking instead.\n\nAnil: There's a healthy followup list of papers, specifically from MSR on [Concurrent Revisions](http://research.microsoft.com/en-us/projects/revisions/).  The cloud types even provide automatic reconciliation, and so are a good fit for the Irminsule model.\n\nMort then described the beginnings of an attempt of implementation of concurrent revisions, with alternate versions using modules and objects (which are closer to the original pseudocode in the paper), but is running into the hard bits of classes in OCaml.  General sounds of sympathy from the group, and advice that classes aren't necessary for many uses of objects in OCaml, and that straightforward object definitions and polymorphism might be easier instead.\n\nRepos are: [froctal](http://github.com/mor1/froctal) and [ocaml-revisions](http://github.com/mor1/ocaml-revisions) on Mort's github.  All work-in-progress, obviously.\n\n!!! Mirage library review\n\nAround 53 libraries in three states, with more coming in fast:\n\n* Not started! (only three of these)\n* Waiting to die! (should be broken up etc)\n* 80% finished! (need docs and interface improvements)\n\nAnil: Note that some OCL people are working on improvements to tooling around documentation, such as [opam-doc](http://www.cl.cam.ac.uk/projects/ocamllabs/tasks/platform.html#OPAM%20Doc).\nShould go though list of libs and define what will get done.\nSee the [dev preview checklist](/wiki/dev-preview-checklist) on the wiki for more information on progress.\n\n!!! AoB\n\nMort: Does anyone else have issues with tuntap on Linux?\nTurns out no-one else has really tried as most of us use Tuntap on MacOS X and the Xen backend on Linux.  Vincent's ocaml-tuntap tests should be sufficient to try a unit test though.\n\n!!! Next week:\n\n* Solidify the story with actor libraries and concurrency from the 1.0 release checklist.\n* Figure out the SSL options for 1.0.\n" ]
 | "wiki/weekly/2013-04-30.md" | "/wiki/weekly/2013-04-30.md" -> Some ["30th April 2013: device drivers, SSL, actors, OpenFlow\n\n!! Agenda\n\n* Moving devices drivers out into userspace (Dave Scott)\n* Cross-compiling MatrixSSL (Jon Ludlam)\n* Js_of_ocaml storage (Anil Madhavapeddy)\n* Actor libraries and the new wg-parallel working group (Anil Madhavapeddy)\n* Openflow (Prashanth Mundkur)\n\nAttendees: Anil Madhavapeddy, Dave Scott, Euan Harris, Amir Chaudhry, Daniel Bunzli, Vincent Bernardoff, Jon Ludlam, Prashanth Mundkur\n\n!!! Moving devices drivers out into userspace (Dave)\n\nGoal is to make the Mirage device driver libraries compile on both UNIX and Xen, so that we can prototype them all in userspace and then just recompile into Xen.  All of the required kernel bits in Linux should be there in 3.5 upwards, such as the `gnttab` and `evtchn` devices. Dave has issued a series of [pull requests](https://github.com/mirage/mirage-platform/pull/29) to make this possible for Mirage Platform, and will merge them this week.  This means that `mirage-platform` now exposes a xenctrl OCamlfind package.\n\n*Anil:* we're missing an example to test userspace bits as a simple unit test.  Perhaps a simple memory-backed block device would be a useful one to include, as there are significant moving parts required to get it up and running at the moment.\n*Jon*: There's some VHD code that we could use and should be in OPAM.\n*Anil:* Even a RAM disk would work initially, before this, just to get functional tests running before anything persistent.\n*Dave*: tricky thing with blkfront is that the API is different between userspace and kernel mode.  Will work on this more with Jon.\n\nVincent also just finished up the [tuntap](https://github.com/vbmithr/ocaml-tuntap) bindings and is working on migrating `mirage-platform` to using it this week.\n*Anil:* Writing up these minutes are a good excuse to regularly rebuild the live `mirage-www` with the latest stuff, so he'll try Vincent's patches when they're ready.\n\n!!! Cross-compiling MatrixSSL (Jon Ludlam)\n\nAnil and Jon attended the [Yahoo hack day](http://www.flickr.com/photos/ydn/8703101338/in/set-72157633314001114). There were giant robots there.  They ended up starting OCaml bindings to MatrixSSL.\n*Jon* just writing bindings to it under the UNIX environment but also has stuff working in Mirage.  This is a good way of getting SSL support into Mirage as an early stepping stone.  \n*Anil:* Lib is GPLv2 so will need to replace at some point but better than OpenSSL for binding.\n*Jon:* could we have Dropbox like functionality. using a VM backend as store. \n*Anil*: yes, with Async/Cohttp this shouldnt be too hard once userspace drivers are working.\n\n*Anil:* Hot off the press are some [FFI bindings](http://github.com/yallop/ocaml-ctypes) by Jeremy Yallop.  Doesn't require any actual C code to bind any more, but still stabilising and perf testing.\n\n*Prashanth*: Anyone looked at [miTLS](http://mitls.rocq.inria.fr/downloads/miTLS-report.pdf) from MSR/INRIA?\n*Anil:* Challenge is to get a verified high-performance version of anything in this space.\n\n!!! Js_of_ocaml storage (Anil Madhavapeddy)\n\nAnil started writing a little abstraction library for js_of_ocaml for storage, for eventual integration into Irminsule.\nIt's a bit complicated as you have to write for the case where local storage is present and where it is not.  Lib helps take care of that so you don't have to worry when writing your stuff. \nNeed a name for this unified library.  Email Anil if you have any ideas! He's going to upload it for next week.\n\n*Daniel:* Need to do some JS hacking so Anil will send stuff to him too.  Also, Anil should check stuff in vg as had to do some similar stuff so check it out and see if there's anything useful in there.   Link is here for [mli](https://github.com/dbuenzli/vg/blob/master/test/mui.mli#L97) and [ml](https://github.com/dbuenzli/vg/blob/master/test/mui.ml#L255).\n\n*Daniel:* Bigarray support in Js_of_ocaml? \n*Anil:* JS has typed arrays instead, but I don't know how many browsers support this.  \n*Daniel:* Canvas may allow you to use that.  \n*Euan:* Everything supports typed arrays except Opera min";
"i (discovered via caniuse.com)\n\n!!! Actor libraries and the new wg-parallel working group (Anil Madhavapeddy)\n\nWe've set up [wg-parallel](http://lists.ocaml.org/listinfo/wg-parallel) for (a) multicore and (b) actor thing for stateless programming.  Euan is cloning Erlang OTP in Async/Core as his \"month off\" project.  wg-parallel not announced to OCaml list yet until we do some preparatory work.\n\nEuan describes his emerging actor library.  Using polymorphic variants as message types. hoping to have type checking between process but running into polymorphism and subtyping issues.  Sent some [emails to list](https://lists.cam.ac.uk/pipermail/cl-mirage/2013-April/msg00069.html) and apparently can't do it the way he wanted (after chatting with Leo).\n\nInteresting thing is really OTP which is how Erlang builds reliable systems on\nmessage passing.  Hope that we might build an OCaml runtime that has separate\nheaps and message passing (of interest to Stephen Dolan and Leo).\n\n*Anil*: Pipes in Async are abstract: they take alpha/beta values and apply flow-control.  The Reader/Writers in Async_unix actually implement TCP. We need a shared memory version.\n*David:* API for [shared-memory-ring](http://github.com/djs55/shared-memory-ring) is mostly good, but quite low-level and needs some work to clean it up with accessors.\n*Euan:* Hello World in Erlang is program called ping-pong.  Haven't benchmarked Erlang's version but OCaml version does 8000 per second.  Will start cross-comparisons with Erlang.\n\n*Prashanth*: For benchmarking, Erlang uses bunch of http stuff.  \n*Euan:* In Erlang, they're less concerned about throughput but about handling multiple connections. It's more about scalability of concurrent connections.  \n\nBrief discussion about load generation for testing purposes and difficulty of spinning up sufficient load to stress a server.  Could use Mirage for better load generators, which would be more widely usable. \n*Anil:* May not want to use multiple experimental systems for testing/benchmarking.  Maybe the stuff for fuzz-testing might be useful for HTTP though.  \n\nwg-parallel list is small at the moment so idea is to start discussion how to move Lwt and Async together.  Just need them to work well together as they're both going to be around for a long time. This is a pressing concern from Mirage which has a significant investment in Lwt but needs to migrate to Async in the longer term.\n\n*Prashanth*: does the actor library consider scheduling to be a concern?  Erlang is pre-emptievely scheduled.  Can be blocked any time you're running.  That's why we need better underlying support in the VM if we want actor model.\n*Anil* believes that we can make it work just fine with UNIX processes and message passing and Monitors.  The emerging multicore OCaml runtime will help.\n\n*Euan:* Hot code reloading in Erlang will be more difficult in OCaml.\n*Anil:* Sounds like xen live-migration, which everyone says is great but don't really use it. \n*Prashanth*: That's one reason why Erlang doesn't have a static type-system (so they can hot-reload).\n*Anil*: we should be looking at service-level hot reload, not at the code level (c.f. the ongoing FRP/React discussion).\n\n!!! Openflow status\n\nPrashanth has been looking at OpenFlow versions and seems lots has changed between recent revisions.  Some of it breaks backwards compatibility, and semantics too. i.e flow matching has changed between 1.1 and 1.3.\n\n*Anil*: nothing we're doing requires compatibility with current hardware so perhaps just work with 1.3 and then figure out a backwards compatible mapping.\n*Prashanth*: I'll send some links to updated spec (find it [here](https://lists.cam.ac.uk/pipermail/cl-mirage/2013-May/msg00000.html)).\n\nNo call next week (7th May) as several members are travelling, but we can resume the call as normal in two weeks on the 14th May.\n\n\n\n\n" ]
 | "wiki/weekly/2013-05-14.md" | "/wiki/weekly/2013-05-14.md" -> Some ["14th May 2013: Ocamlot, actors and performance\n\n!! Agenda\n\n* Ocamlot update and use in Mirage (Anil, David Sheets)\n* Actors: Dave's been working on this with his message switch\n* Performance testing (all!)\n* CHERI/MIPS64 discussion\n\n*Attendees:* Anil Madhavapeddy, David Scott, Richard Mortier, Thomas Gazagnaire,\nPrashanth Mundkur, Balraj Singh, Euan Harris, Amir Chaudhry, David Sheets, Jon\nLudlam, Vincent Bernardoff, David Sheets\n\n!! OCamlot\n\nOCamlot is coming together and should go live in a couple of weeks.  It is\ncurrently using Lwt but will eventually transition to Async.  It can download\nfrom a GitHub pull-request, merge the OPAM repositories locally, and run tests.\nWe will get this up and running in Computer Lab soon with machines here, but\ncould use more resources and hardware from Citrix and others.  \n\n*David Sheets:* I want to be able to get event notification and know when data\nstructures change and get the functional diff between old and new (as well as\nthe new).  *Anil:* This sounds suspiciously similar to what Irminsule could\noffer. We're going to work with Thomas next week to figure out how all this\nfits together.\n\n*Dave Scott:* Citrix also needs a simple messaging system, with queues persistent in memory (not necessarily on disk).  This all needs to run on a Mirage VM also, and will coordinate the nextgen microkernel architecture.\nApps will talk about named queues of events. The current implementation uses file descriptor passing but will fall back to TCP if across different hosts in the cluster. Using Lwt at the moment. It's a [prototype on Github](http://github.com/djs55/message-switch] so feedback on semantics would be helpful.  Taken some ideas from OpenStack etc. Could use Fable when it's ready (looks pointedly at Anil).\n\n*Anil:* This work may unblock some of the OCamlot prototyping too.  We can use Irminsule when ready but leave that out for the very first release of OCamlot, since we need tests running asap.  However, this all converging nicely for the longer term.\n\n!! Actor\n\nEuan Harris continues to work on the actor library, although he's mainly on the\nlow-level end of things at the moment.  Two significant other interface-related\nthings were pointed out.\n\n*Anil Madhavapeddy:* Daniel Bunzli is working on a really nice [Vg](http://erratique.ch/software/vg/demos/rhtmlc.html#color-grayscale-ramp) graphing library suite which will help visualise actor interactions.\n*Thomas Gazagnaire*: Have you seen the [Akka demo](http://console-demo.typesafe.com/demo@typesafe.com/Demo/) console, which provides similar functionality for Scala.\n\n*Anil:* Balraj had a localhost web server embedded directly into the Mirage TCP\nstack for debugging.  This actor approach offers us a well-structured\nalternatives to such daring hacks.  It would be great to be able to recompile\nthe whole stack into debug mode, with RPCs flying around instead of function calls.\nRPCs are far easier to debug. *Balraj* agrees that a more general solution would\nbe useful.\n\nCohttp is much more stable, and it's functorised cleanly now. Citrix has their\nown IO monad for it using regular buffered IO over channels using FD\nreading/writing. There are an increasing number of third-party projects using\nCohttp, so we really do need to get a stable version out.\n\n!! Performance\n\nNeed to do testing for All the Things, preferably on an ongoing basis within\nOCamlot!  Since we're now on release track this matters far more than when it\nwas just prototypes for research papers.  We don't have a full regression suite\nto work off yet.\n\nFor now, we should just pick a set of reasonable tests per library.  Balraj had\nsome for the TCP stack, Anil will put together for HTTP stack.  Mark Shinwell\nis working on some very useful allocation profiling patches that should be\nready in a month or earlier.\n\n*Balraj:* Example test for TCP might be the 10MM concurrent connections. We\nshould be able to do that without too much sweat.  \n\n*Anil:* For HTTP, can use httperf.  Curious to see where we are with that and\nhow we compare with nginx, as we were competitive in the ASPLOS paper bu";
"t may\nhave regressed.\n\nHaving performance tests as part of libraries is a good idea so that they can\nbe run by Ocamelot automatically.\n\n!!! Repository management.\n\n80+ repos now listed on wiki. Maybe add info on testing status to this list\nalso.  Dave and Jon and Anil will chat separately about writing Github scripts\nto help manage these repositories as a cluster.\n\n!! MIPS64/CHERI port\n\nPrashanth Mundkur is looking into getting OCaml into CHERI (a MIPS 64\nexperimental CPU developed at the Computer Lab and SRI International).  Anil\nsuggests looking at porting OCaml into stackless mode so it doesn't share\nthe C stack, which would break the FFI very slightly, but be easier to segment.\n\nThere were some patches flying around a few years to implement this directly\nin ocamlopt, and Anil will investigate.\n\n!!! AoB\n\nA number of Cambridge students are going to Jane Street for internships, and\nwe're synching up projects so that they can continue after the summer.  Ideas\nfor internships welcome.\n" ]
 | "wiki/weekly/2013-05-21.md" | "/wiki/weekly/2013-05-21.md" -> Some ["21 May 2013: Build, build, build, argh.\n\n!! Agenda\n\n* Mirari update (Vincent)\n* Jenga (Dave)\n\n*Attendees:* Amir Chaudhry, Anil Madhavapeddy, Thomas Gazagnaire, Richard Mortier, Daniel Buenzli, David Scott, Jonathan Ludlam\n\n# Jenga (Dave Scott)\n\nJane Street has released a preview of Jenga onto OPAM, which is a library for\nhighly scalable builds.  It includes dynamic discovery of dependencies and\nAsync build rules so network targets can work.\n\nDave: Jenga looks attractive for a number of reasons, including incremental builds.\n\nAnil: We need a build tool that doesn't suck and that someone cares about (i.e. will maintain).  Jenga does have a big user behind it. Prefer to take something and make it portable rather than continue a forked one.\n\nDave: Should be easy to make it work for our small projects. \n\nAnil: Key blocker is getting it to work on a Mac.  If you've tried it then do\ntell people what didn't work on the Mirage list! Jane Street put it out there\nin order to get feedback so they do want to know what people think.\n\nJane Street is rolling out Jenga for their internal stuff now so it'll start\nsettling down very fast.  We have the next two weeks to get big changes in while\nthings are fluid.  We can make Mirari interface with Jenga, for example.\n\nDaniel: Jenga only covers build, but not distribution (making META files, etc).\nHow do we deal with that?\n\nAnil: We take the good bits of obuild and use them to build Jenga rules.\nThere's also ocp-build hiding in the shadows.  It's technically very nice\nbut not fully released, and doesn't have output-obj (but that's easy to add).\n\nDave: Another option is to slice out the distribution library from obuild\n(which has a good META parser that's standalone).\n\nAnil: Hoping to get Jenkins running again, since Balraj notices trunk is broken\nagain while working on perforamce stuff.  We need to remove opam-repo-dev\nas it's always breaking dependencies silently.\n\nMort: Kind of works on Linux, but we still need to run `tunctl` by hand.\nAnil: Mirari should fix this up automatically, so I'll take a look in the next few weeks.\n\nJon: Vincent Bernardoff is working on the Xen unikernel testing infrastructure\nwith Mirage, so we'll wait to hear from him to see what he's done (test VM and\nTest harness). Could use that to test the Unix backend too.\n\nAnil: In OPAM can use OCamlot can do a bunch of scripts (not just OCaml). We\nneed to figure out where to host VMs though, as the Lab is unsuitable for\nongoing deployments due to lack of sysadmin cover.\n\n!! AoB\n\n!!! cohttp\n\nAnil: About to release a new cohttp and want to hook it up to a graphing system for plots.  Can this connect with Daniel's vg? Can try getting raw numbers out now and then attach graphics after.  Does vg need a particular format?\n\nDaniel: Vg is usable now and installable via opam.  JSON is fine but don't need\nanything particular. We need a release of OPAM 1.0.1 to fix a bug with unstable\ngit remotes.\n\nAnil: Jeremy's Libffi (ctypes) now works on Mac and Linux. Have ncurses and\nvarious POSIX bindings working!  In the worst case it's 10x slower (usu 2-3 x\nslower) but you don't have to write any C, and we know how to fix the slowdown.\nIt'll be open-source very soon.\n" ]
 | "wiki/weekly/2013-05-28.md" | "/wiki/weekly/2013-05-28.md" -> Some ["28 May 2013: Build pain reduced to mild ache, Try Mirage, Benchmarking available\n\n!! Agenda\n\n* Build progress since last week\n* Exploring a Try Mirage site for launch\n* Benchmarking progress with Core_bench\n\n*Attendees*: Balraj Singh, Anil Madhavapeddy, Amir Chaudhry, David Sheets, Jonathan Ludlam, Thomas Gazagnaire, Prashanth Mundkur, Vincent Bernardoff, Mike McClurg, Daniel Buenzli\n\n!! Build update\n\nDave: An obuild 0.0.2 snapshot has been uploaded to OPAM that fixed lots of bugs and is\ngenerally very usable.\n\nAnil: we would like to use Jenga in Real World OCaml, but it's still not\nportable to the Mac (there is ongoing work in ocaml-plugin to make this work\nthere). \n\nThomas: ocp-build is working nicely but not well-documented due to lack of\ntime. The front end isn't great but it's designed to be generated from other\ntools (Fabrice is willing to improve it).  We would like input on what is\nrequired would not be difficult to adapt it.\n\nAnil: One nice feature of Mirari is that dependencies can be auto-installed\nduring the configure phase. We like OPAM to understand build a bit more and\nautomate things more easily in the longer-term.  e.g Parse OASIS file and\ngenerate meta files.  Jenga doesn't have that.\n\nThomas: We need something more concrete in the build space, or we won't\nmake progress.\n\nAnil: We're driven by the 1.0 deadlie in July at the moment, and can then take\nsome breathing room to work on the longer term solution. Sounds like it comes\ndown to OASIS being ok for now, and Mirari being an interface to the application\nconstruction. (general agreement from the room)\n\n!! Try Mirage\n\nAnil: Many people want to try Mirage, but blocked by not having Xen\ninstallation handy. Can we figure out a way to expose a machine for people to\nbuild quickly (e.g. for few mins), or is this too painful?  We can seed this\neffort from the Lab (but do actually need the machines for research).\n\nDave Scott: possible to find VMs, but hosting within Citrix firewall is\nproblematic due to (entirely valid) security concerns.\n\nAnil: would be good to get EC2 bindings sorted soon, as we should be able\nto run the main website on it again.  Vincent: he has ported barko's AWS\nbindings to the newest Cohttp already, but not tested it.\n\nBalraj: The TCP stack should be fine to run a live site on.  All the current\nbugs are deep in microbenchmarks such as 1-byte writes and far from the\nday-to-day stuff a website would see. (muttering of \"famous last words\" from\nthe room).\n\nAnil: xen.openmirage.org has been running on EC2 for 20 months and seems ok (but don't all visit at once!).\n\n!! Benchmarking and visualisation\n\nAnil: I've just written a bunch of Real World OCaml text that uses Core_bench, and it's an execllent library.  Can we generate visual graphs from Daniel's library?\n\nDaniel: Having some issues with glyphs in the Canvas backend, but should be ok aside from that.\n\nAnil: How dependant are we on the browser output? Is there an SVG output? can we build graphs that don't depend on Canvas?\n\n(the answer to all the above questions are affirmative)\n\nDavid Sheets: I'd like to be able to plot stats curves for Ocamlot for queue length and worker utilization.\n\nDaniel: This should be ok from now.  Just need to look at the glyphs thing.\n\nAnil: Going to wait until tuntap is stable and then breakup the network stack\nto aid benchmarking.  Helps other people to use (and contribute to) these other\nlibraries.  Vincent has been Ocamldoc-ing as he goes along and that's been\n*very* useful.  It's hard to do that in one go but as you go along its much\neasier.  Please do this for the libs that you are working on.\n\n\n\n\n\n\n\n\n\n\n" ]
 | "wiki/weekly/2013-06-04.md" | "/wiki/weekly/2013-06-04.md" -> Some ["6th June 2013: EC2, shared ring performance and outreach\n\n*Attendees:* Jonathan Ludlam, Vincent Bernardoff, Dave Scott, Anil Madhavapeddy, Amir Chaudhry, Mike McClurg\n\n!! Mirari\n\nExcellent progress on Mirari from Vincent, who will have patches available soon for merging.\n\nAnil: main last change we need to make is to stop Mirari from requiring OPAM\nswitch.  This is because it forces you to compile a new compiler (takes a long\ntime) just to build a Xen kernel.  Instead, we can use the OPAM constraint\nsolver to do the selection of packages rather than environment variables.\n\nAll agreed (Thomas is on vacation but agreed this would work earlier on a cl-mirage\nmail thread).  This should be the last breaking change in the build infrastructure\nbefore the release, so we'll aim to integrate by next week.\n\n!! Testing and EC2 integration \n\nVincent: There is no automatic way to set up a free EC2 for Mirage with micro.\nYou have to do it by hand each time you want to upload a kernel.  \n\nAnil: We also need reliable shutdown hooks for EC2, or risk spending lots of cash by mistake! \n\nBalraj has been playing with performance to optimise the network stack.  Some\nquestions about perf and Xen: there doesn't appear to be a perf-xen mode\nalthough there is a perf-kvm mode.  OCaml 4.1-trunk has really good CFI stubs\nthat make using perf almost pleasant.\n\nnil: Tom Ridge is just starting work on building a verified filesystem in\nOCaml, so we had a meeting about that with Thomas Gazagnaire last week.  Very\nexciting work, as it should be easy to hook into Mirage.\n\nSome discussion of the RPC mechanism for Vincent's testing infrastructure.  Consensus\nis that instead of using Xenstore as an RPC mechanism, we should use an explicit\nlibvchan communication channel instead.  This would let us build command-line\ntools for vchan that make it easier to manipulate the kernel.\n\nBalraj also raised the question of TCP and intended behaviour of the ring\ninterface with fragmentation.  His tests run very small packets (below TCP\nminimum size) and deadlock if the ring doesn't have enough free slots.\nDave/Anil think that we need to lock the shared rings to queue up producers (so\nthat we dont end up with out-of-order packets on the wire) and also provide a\nnew function to request a reservation of multiple contiguous ring slots.  Dave\nwill look into this further.\n\n!! Outreach\n\nAnil: Preparing for the release in July, we need to think about what blog posts\npeople would be interested in.\n\nAnil: A really good blog post for Dave would be how to build a userspace block\ndevice in pure OCaml that provides storage to VMs.  For a memory device, we\ncould pretty much build this from the OCaml toplevel in dom0.\n\nJon: I like the idea of getting people to do screen-casts.\n\nAnil: Aim for one high quality blog post from everyone every two months.\nShould be able to get a post up every two weeks then.  Every post should think\nabout its target (level of Xen familiarity, etc).  Lars from Xen.org could\nadvise on this.\n\n!! Merging to trunk\n\nVincent: Can someone look at Unix back-end and code-review the shift\nto multiple processes for UNIX.\n\nAnil: on the queue for this week, and will definitely have it merged by\nnext week's meeting. This will very likely break trunk for a little while\nsince I'll do the OPAM rearrangement at the same time.\n\n!! SSL libraries\n\nAnil: Now that ctypes is released, we should look at SSL alternative bindings again.\nPrashanth pointed out axTLS, which is a BSD licensed alternative to MatrixSSL and\ntherefore worth looking into more (but it's API isn't quite as agnostic to sockets\nas MatrixSSL, sadly, but should still work fine as sockets can be nonblocking in\nthe axTLS world).\n\n" ]
 | "wiki/weekly/2013-06-11.md" | "/wiki/weekly/2013-06-11.md" -> Some ["11th June 2013: the end of the start is in sight\n\n!! Agenda\n\nWork through the integration of:\n\n* the new UNIX backend which spins off a separate unikernel process\n* the elimination of OPAM switch from the mirari workflow\n* binary package generation\n\nAttendees: Anil Madhavapeddy, David Scott, Vincent Bernardoff, Daniel Buenzli, Jonathan Ludlam\n\n!! Notes\n\nVincent's patchset successfully split out much of the UNIX dependencies into\nsmaller libraries.  Anil has been code-reviewing and integrating them, and now\nhas a working Mirage again in trunk!  \n\nThe new OPAM scheme breaks up:\n\n* `mirage` into `mirage-unix` and `mirage-xen`\n* `mirage-net` into `mirage-net-direct` and `mirage-net-socket`\n* Adds a dependency of the form `(mirage-unix|mirage-xen)` to the now-dummy `mirage` package.\n* Adds conflicts to each other on `mirage-unix` and `mirage-xen`.\n\nThis all means that we no longer need to use a separate compiler switch for\ncompiling UNIX and Xen backends, thus simplifying mirari considerably.  Dave\nadded a patch which stubs out `mmap`, also eliminating the need for the\n`xenbigarray` package.\n\nAnil will push all these changes to trunk and cut a new set of releases with this\nscheme.  This should be the last of the changes required before a beta!\n\nAnil: trunk compiler seems broken with Xen due to missing symbols Dave: yes, as\nthey have been added since 4.00.1 was released.  Decision to stick with 4.00\nfor now, as we don't require the 4.1 features (but they speed up the unikernel\na lot, but performance isn't priority just yet).\n\n!! Next Steps\n\nWe're going to aim to stabilize everything for two weeks.\n\n* Vincent: get EC2 bindings in shape.\n* Anil: try out libvirt\n* Anil: look at plumbing through block storage in mirari.\n* Dave: fixing Balraj's network ring reservation query.\n* Dave: look at pulling out FAT32 (still using Bitstring).\n* Vincent: write blog post on Mirari.\n* Vincent/Dave: look at evtchn unification and test cases for event handling.\n\nAnil will chat with David Sheets about getting continuous builds runnings now\nthat it's all part of the mainline.\n\n!! Binary packages\n\nDiscussion about whether we could use OCamlot for binary distribution\ngeneration, as Dave and Jon have been knocking out RPM spec files at an\nalarming rate.  We also need this to generate binary distribution of Mirage for\nthe OSCON preview.\n\nJon/Dave/Citrix are working with upstream CentOS, so this is the first place to start. \nAnil: we can customise OCamlot much more easily than Jenkins, so this should be good to hook in.\n" ]
 | "wiki/xen-boot.md" | "/wiki/xen-boot.md" -> Some ["The `mir-xen` build script outputs a Xen PV kernel with a `.xen` extension. This must be booted as a normal Xen domU kernel. The specifics vary based on your setup or cloud provider.\n\n!!Open Source Xen\n\nWhen using open-source Xen, you need to create a configuration file for the VM that looks something like:\n\n```\nname=\"app\"\nmemory=1024\nkernel=\"app.xen\"\nvif=['bridge=eth0']\nsuperpages=1\n```\n\nYou can launch this domain with `xm create -c app.cfg` (for Xen versions earlier than 4.1) and `xl create -c app.cfg` for Xen 4.1 or greater.\n\n!!Amazon EC2\n\nAmazon has recently added support for booting [user-specified kernels](http://ec2-downloads.s3.amazonaws.com/user_specified_kernels.pdf). This involves a two-stage boot procedure behind the scenes:\n\n* The VM is launched using a `pvgrub` stub domain that is a micro-kernel containing a small grub interpreter.\n* `pvgrub` mounts the root device, looks for `/boot/menu.lst`, and parses it for the default kernel location on that filesystem.\n* The actual kernel is loaded into memory, and `pygrub` execs it, erasing it from memory.\n* From this point on, the second kernel is active and boot proceeds normally.\n\nSo to boot a Mirage kernel on EC2, it must first be wrapped in a block device. After that, the image needs to be bundled into an AMI, and then registered as a bootable image using the EC2 tools.\n\n!!!Command Line Tools\n\nFirst download the [tools](wget http://s3.amazonaws.com/ec2-downloads/ec2-ami-tools.zip) from Amazon.\nEdit your `.profile` to add the following variables:\n\n* `EC2_USER`: 12 digit account number (not email) obtained from the EC2 management console.\n* `EC2_ACCESS`: from Account/Access credentials in the EC2 management console.\n* `EC2_ACCESS_SECRET`: as above, in a different tab.\n* `EC2_CERT`: location of the certificate file you download from the Account/Access page.\n* `EC2_PRIVATE_KEY`: location of the private key.\n\nThere is a script that then takes care of packaging up the Mirage kernel image and uploading it to Amazon automatically..\nIt is in [scripts/ec2.sh](https://github.com/avsm/mirage/tree/master/scripts/ec2.sh), and you specify your `kernel.xen` file as the first argument to the script.\n\n!!! Using mirco instances\n\nTo use the EC2 `t1.micro` instances the kernel needs to reside inside an EBS volume. To create a bootable EBS volume containing an Mirage kernel use the following steps:\n\n* Start a t1.micro instance: `ec2-run-instances ami-7f418316 -k mirage -t t1.micro` - We need this instance to access the EBS volume which will later contain our Mirage kernel\n* Create an EBS volume: `ec2-create-volume --size 1` - We use the smallest possible size: 1G\n* Attach volume to your instance: `ec2-attach-volume ${VOLUME} -i ${INSTANCE} -d /dev/sdh` - Where `$VOLUME` is your volume id and `$INSTANCE` is your instance id\n* Login to the miro instance using ssh: `ssh -i mirage-ssh-key.pem ec2-user@${PUBLIC-AWS-NAME}` - Where `$PUBLIC-AWS-NAME` is your public DNS name of your running micro instance\n* Create a partition on `/dev/sdh` and format it using `mkfs.ext2 /dev/sdh1` and mount the volume: `sudo mount /dev/sdh1 /mnt`\n* Copy a Xen Mirage kernel (e.g. the http example with DHCP enabled) to the running micro instance\n* Login via ssh and move the kernel to `/mnt/kernel`\n* Create grub directories `sudo mkdir -p /mnt/boot/grub/`\n* Create grub menu.lst file in `/mnt/boot/grub/menu.lst`\n\n    default 0\n    timeout 1\n    title Mirage-Test\n         root (hd0,0)\n         kernel /kernel \n\n* Log out of instance\n* Create EBS snapshot `ec2-create-snapshot ${VOLUME}`\n* You can stop the running mirco instance now\n* Register your AMI using `ec2-register --snapshot ${SNAPSHOT} --kernel aki-4e7d9527 --architecture x86_64` Note the familiar kernel id: This is the pv-grub kernel that is also used in `script/ec2.sh`.\n* Start your EBS backed Mirage kernel in a micro instance: `ec2-run-instances ${EBSAMI} -k mirage -t t1.micro`\n\nThis process could be put in a script easily. \n\n!!Xen Cloud Platform\n\nThe [Xen Cloud Platform](http://www.xen.org/products/cloudxen.html) is a distribution that provides cluster-wi";
"de support for multi-tenant VMs. It uses a command-line interface and an XML-RPC API to configure and control VMs.\n\nThere is a script in [scripts/xcp.sh](https://github.com/avsm/mirage/tree/master/scripts/xcp.sh) that takes a `kernel.xen` output from Mirage and makes the appropriate API and SSH calls. Thanks to [Mike McClurg](https://twitter.com/mcclurmc) from Citrix for contributing this script.\n\n!!Rackspace\n\nNoone has tried this yet. Get in touch if you do!\n" ]
 | _ -> None

let file_list = ["wiki/weekly/2013-05-28.md"; "wiki/repo-layout.md"; "wiki/net-unix.md"; "about-proj.md"; "blog/welcome.md"; "wiki/ocaml-regexp.md"; "blog/the-road-to-a-dev-release.md"; "about.md"; "wiki/talks.md"; "wiki/opam.md"; "wiki/hello-world.md"; "blog/announcing-mirage-openflow.md"; "arch.md"; "about-r.md"; "wiki/tutorial-lwt.md"; "wiki/delimcc-vs-lwt.md"; "wiki/mirage-www.md"; "blog/breaking-up-with-opam.md"; "blog/xenstore-stub.md"; "wiki/weekly/2013-05-21.md"; "wiki/dev-preview-checklist.md"; "iconize.css.inc"; "main.html"; "wiki/weekly/2013-04-30.md"; "wiki/htcaml.md"; "wiki/xen-boot.md"; "wiki/weekly/2013-04-16.md"; "wiki/weekly/2013-05-14.md"; "blog/an-outing-to-cufp.md"; "wiki/weekly/2013-06-11.md"; "wiki/install.md"; "blog/spring-cleaning.md"; "intro-r.html"; "docs.md"; "wiki/index.md"; "wiki/weekly/2013-04-23.md"; "intro.md"; "blog/xen-block-devices-with-mirage.md"; "wiki/weekly/2013-06-04.md"; "wiki/cow.md";  ]
let size = function
 |"wiki/weekly/2013-05-28.md" |"/wiki/weekly/2013-05-28.md" -> Some 3633L
 |"wiki/repo-layout.md" |"/wiki/repo-layout.md" -> Some 8011L
 |"wiki/net-unix.md" |"/wiki/net-unix.md" -> Some 5115L
 |"about-proj.md" |"/about-proj.md" -> Some 355L
 |"blog/welcome.md" |"/blog/welcome.md" -> Some 562L
 |"wiki/ocaml-regexp.md" |"/wiki/ocaml-regexp.md" -> Some 4675L
 |"blog/the-road-to-a-dev-release.md" |"/blog/the-road-to-a-dev-release.md" -> Some 4310L
 |"about.md" |"/about.md" -> Some 1149L
 |"wiki/talks.md" |"/wiki/talks.md" -> Some 1483L
 |"wiki/opam.md" |"/wiki/opam.md" -> Some 1664L
 |"wiki/hello-world.md" |"/wiki/hello-world.md" -> Some 2429L
 |"blog/announcing-mirage-openflow.md" |"/blog/announcing-mirage-openflow.md" -> Some 3727L
 |"arch.md" |"/arch.md" -> Some 917L
 |"about-r.md" |"/about-r.md" -> Some 345L
 |"wiki/tutorial-lwt.md" |"/wiki/tutorial-lwt.md" -> Some 21431L
 |"wiki/delimcc-vs-lwt.md" |"/wiki/delimcc-vs-lwt.md" -> Some 15327L
 |"wiki/mirage-www.md" |"/wiki/mirage-www.md" -> Some 2001L
 |"blog/breaking-up-with-opam.md" |"/blog/breaking-up-with-opam.md" -> Some 4315L
 |"blog/xenstore-stub.md" |"/blog/xenstore-stub.md" -> Some 8156L
 |"wiki/weekly/2013-05-21.md" |"/wiki/weekly/2013-05-21.md" -> Some 3205L
 |"wiki/dev-preview-checklist.md" |"/wiki/dev-preview-checklist.md" -> Some 4642L
 |"iconize.css.inc" |"/iconize.css.inc" -> Some 4600L
 |"main.html" |"/main.html" -> Some 1572L
 |"wiki/weekly/2013-04-30.md" |"/wiki/weekly/2013-04-30.md" -> Some 7959L
 |"wiki/htcaml.md" |"/wiki/htcaml.md" -> Some 4814L
 |"wiki/xen-boot.md" |"/wiki/xen-boot.md" -> Some 4560L
 |"wiki/weekly/2013-04-16.md" |"/wiki/weekly/2013-04-16.md" -> Some 8711L
 |"wiki/weekly/2013-05-14.md" |"/wiki/weekly/2013-05-14.md" -> Some 5095L
 |"blog/an-outing-to-cufp.md" |"/blog/an-outing-to-cufp.md" -> Some 5191L
 |"wiki/weekly/2013-06-11.md" |"/wiki/weekly/2013-06-11.md" -> Some 2534L
 |"wiki/install.md" |"/wiki/install.md" -> Some 4328L
 |"blog/spring-cleaning.md" |"/blog/spring-cleaning.md" -> Some 2869L
 |"intro-r.html" |"/intro-r.html" -> Some 7097L
 |"docs.md" |"/docs.md" -> Some 527L
 |"wiki/index.md" |"/wiki/index.md" -> Some 1879L
 |"wiki/weekly/2013-04-23.md" |"/wiki/weekly/2013-04-23.md" -> Some 6141L
 |"intro.md" |"/intro.md" -> Some 1349L
 |"blog/xen-block-devices-with-mirage.md" |"/blog/xen-block-devices-with-mirage.md" -> Some 11223L
 |"wiki/weekly/2013-06-04.md" |"/wiki/weekly/2013-06-04.md" -> Some 3696L
 |"wiki/cow.md" |"/wiki/cow.md" -> Some 9577L
 |_ -> None

end

let name="crunch"

let file_list = Internal.file_list
let size name = Internal.size name

let read name =
  match Internal.file_chunks name with
  |None -> None
  |Some c -> Some (String.concat "" c)
