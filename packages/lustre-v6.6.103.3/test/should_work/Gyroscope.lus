const DELTA_ROLL = 2.0;
const DELTA_PITCH = 2.0;
const DELTA_YAW = 2.0;

const GOD_ROLL = 15.0;
const GOD_PITCH = 16.0;
const GOD_YAW = 14.0;

const DELTA_TO_GOD_ROLL = 2.0;
const DELTA_TO_GOD_PITCH = 2.0;
const DELTA_TO_GOD_YAW = 2.0;

const TIME = 3;

type Valid_ChannelT={local_failure : bool; local_value : real};
type Faulty_ChannelT={valuea : real; valueb : real};
type Faulty_Array=Faulty_ChannelT^4^3;


node countFalse(accu_in : real; elt_in : Valid_ChannelT) returns (accu_out : real);
let
   accu_out = if(elt_in.local_failure) then accu_in else (accu_in + 1.0);
tel


node countValidChannels(channels : Valid_ChannelT^4) returns (nb : real);

let
   nb = red<<countFalse;4>>(0.0,channels);
tel


node assumeSum (accu_in : real; elt_in : real) returns (assumeOK : bool);
var varBidon : real;
let
-- R1: fix that non-def local
  varBidon = 1.0;
  assumeOK = varBidon < elt_in;
tel

node guaranteeSum (accu_in : real; elt_in : real; accu_out : real) returns (guaranteeOK : bool);
var otherVarBidon : real;
let
-- R1: fix that non-def local
  otherVarBidon = 1.0;
  guaranteeOK = elt_in + otherVarBidon < accu_out;
tel



node sum
%ASSUME:assumeSum%
%GUARANTEE:guaranteeSum%
(accu_in : real; elt_in : real) returns (accu_out : real);
let
   accu_out = (accu_in + elt_in);
tel


node masking(channel : Valid_ChannelT) returns (out : real);
let
   out = if(channel.local_failure) then 0.0 else channel.local_value;
tel


node abs(in : real) returns (out : real);
let
   out = if((in < 0.0)) then -(in) else in;
tel


node assumeVoter(channels : Valid_ChannelT^4; god : real; delta_to_god : real) returns (assumeOK : bool);
let
   assumeOK = true;
tel


node iteratedVoter(acc_in :  bool; channel : Valid_ChannelT; god,  delta_to_god, vote : real) returns (acc_out : bool);
let
  acc_out = acc_in and (channel.local_failure or (abs((vote - channel.local_value)) < delta_to_god));
tel

node guaranteeVoter(channels : Valid_ChannelT^4; god : real; delta_to_god : real; vote : real) returns (guaranteeOK : bool);
let
  guaranteeOK = red<<iteratedVoter;4>>(true, channels, god^4, delta_to_god^4, vote^4);
tel


node Voter
%ASSUME:assumeVoter%
%GUARANTEE:guaranteeVoter%
(channels : Valid_ChannelT^4; god : real; delta_to_god : real) returns (vote : real);
   var globalSum : real; nbValid : real; mask : real^4; 
let
   nbValid = countValidChannels(channels);
   globalSum = red<<sum;4>>(0.0,mask);
   vote = (globalSum / nbValid);
   mask = map<<masking;4>>(channels);
tel


node Voter2(channels : Valid_ChannelT^4; god : real; delta_to_god : real) returns (vote : real)
   var globalSum : real; nbValid : real; mask : real^4; 
let
   nbValid = 0.0;
   globalSum = 0.0;
   vote = 0.0;
   mask = map<<masking;4>>(channels);
tel



--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
node assumeChannel(inChannel : Faulty_ChannelT; delta : real; god : real; delta_to_god : real) returns (assumeOK : bool);
let
   assumeOK = true;
tel


node guaranteeChannel(inChannel : Faulty_ChannelT; delta : real; god : real; delta_to_god : real; outChannel : Valid_ChannelT) returns (guaranteeOK : bool);
let
   guaranteeOK = outChannel.local_failure or ((abs((inChannel.valuea - outChannel.local_value)) < delta) and (abs((inChannel.valueb - outChannel.local_value)) < delta));
tel


node Channel
%ASSUME:assumeChannel%
%ASSUME:guaranteeChannel%
(inChannel : Faulty_ChannelT; delta : real; god : real; delta_to_god : real) returns (outChannel : Valid_ChannelT);
var maintain : bool;
let
-- Il faut se servir de l'utilitaire Maintain:  
-- ce noeud détecte des problèmes pendant une certaine periode sur un même channel 
   maintain = Maintain(TIME, abs((inChannel.valuea - inChannel.valueb))>delta);
   outChannel = Valid_ChannelT{local_failure = maintain;
                 local_value = if(maintain) then 0.0 else ((inChannel.valuea + inChannel.valueb) / 2.0)};
-- Vieille version, sans le maintain:  
--   outChannel = {local_failure = (abs((inChannel.valuea - inChannel.valueb)) > delta),
--local_value = if((abs((inChannel.valuea - inChannel.valueb)) > delta)) then 0.0 else ((inChannel.valuea + inChannel.valueb) / 2.0)};
tel

node Maintain (n : int ; val : bool) returns (m : bool) ;
var cpt : int ;
let
        cpt = (if val then 1 else 0) ->
               if val then min_int (n, pre(cpt) + 1) else 0 ; 

        m   = (cpt >= n) ;
tel


node min_int(n1, n2 : int) returns (n : int);
let
  n = if n1>n2 then n2 else n1;
tel
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%







--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
node TooFar(nbToFarIn : int; channel : Faulty_ChannelT; god : real; delta_to_god : real) returns (nbToFarOut : int);
let
   nbToFarOut = if((abs((channel.valuea - god)) < delta_to_god)) then (nbToFarIn + 1) else nbToFarIn;
tel


node assumeEvaluateAxis(channels : Faulty_ChannelT^4; delta : real; god : real; delta_to_god : real) returns (assumeOK : bool);
var NbToFar : int;
let
   NbToFar = red<<TooFar;4>>(0,channels,god^4,delta_to_god^4);
   assumeOK = NbToFar <= 1;
tel

node guaranteeEvaluateAxis(channels : Faulty_ChannelT^4; delta : real; god : real; delta_to_god : real; AxisValue : real) returns (guaranteeOK : bool);
let
  guaranteeOK = abs((AxisValue - god)) < delta_to_god;
tel


node EvaluateAxis
%ASSUME:assumeEvaluateAxis%
%GUARANTEE:guaranteeEvaluateAxis%
(channels : Faulty_ChannelT^4; delta : real; god : real; delta_to_god : real) returns (AxisValue : real);
   var resChannels : Valid_ChannelT^4; 
       AxisValue2 : real;
let
   resChannels = map<<Channel;4>>(channels,delta^4,god^4,delta_to_god^4);
   AxisValue = Voter(resChannels, god, delta_to_god);
   AxisValue2 = Voter2(resChannels, god, delta_to_god);
tel
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


node ValueIsSecure(secure_value : real; delta_to_god_value : real; god_value : real) returns (is_valid : bool);
let
   is_valid = (abs((secure_value - god_value)) < delta_to_god_value);
tel


node ValueIsSecureII(accu_in : bool; secure_value : real; delta_to_god, god_value : real) returns (is_valid : bool);
let
   is_valid = ((abs((secure_value - god_value)) < 2.0) and accu_in);
tel


node Gyroscope(axis : Faulty_Array) returns (valid : bool);
   var secure_values : real^3; 
let
   secure_values = map<<EvaluateAxis;3>>(axis,[DELTA_ROLL,DELTA_PITCH,DELTA_YAW],[GOD_ROLL,GOD_PITCH,GOD_YAW],[DELTA_TO_GOD_ROLL,DELTA_TO_GOD_PITCH,DELTA_TO_GOD_YAW]);
--   valid = forall<<ValueIsSecure;3>>(secure_values,[DELTA_TO_GOD_ROLL,DELTA_TO_GOD_PITCH,DELTA_TO_GOD_YAW],[GOD_ROLL,GOD_PITCH,GOD_YAW]);
   valid = red<<ValueIsSecureII;3>>(true,secure_values,[DELTA_TO_GOD_ROLL,DELTA_TO_GOD_PITCH,DELTA_TO_GOD_YAW],[GOD_ROLL,GOD_PITCH,GOD_YAW]);
tel
