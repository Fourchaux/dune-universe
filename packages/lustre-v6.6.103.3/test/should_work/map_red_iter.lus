----------------------------------------------------
--Maquette du noeud traite_gen :
--  On a juste mis le calcul du TabComVal,
--   le reste etant realise par un ``noeud'' abstrait
----------------------------------------------------

------------------------------------------
-- Constantes
------------------------------------------
const NBC = 20;
const NBG = 4;

----------------------------------------
--Types :
------------------------------------------
type INTNBC = int^NBC;
type INTNBG = int^NBG;

type T_EntreeGlob = {
        chg2gen      : INTNBC;  -- ch2gen[i] est le Numero du generateur sur lequel 
                            -- la charge i est branchee (correspondance charge/generateur)
        mesure_chgs  : INTNBC;  -- Les charges qu'on a
        mesure_gens  : INTNBG}; -- Les generateurs

type T_InfoChgIndiv = {
        mesure_chg : int};

type T_InfoChgGlob = {
        chg2gen : INTNBC};

--type T_EtatCharge = enum {
--      EC_ON, EC_OFF, EC_NON_CTRL, EC_LESTAGE, EC_DELESTAGE};
type T_EtatCharge = int;

type T_InfoGenIndiv = {
        mesure_gen : int};

type T_InfoGenGlob = {
    elt_bidon : int;
     chg2gen : INTNBC};

--type T_ComChg = enum {
--      COM_ERR, COM_ON, COM_OFF};
type T_ComChg = int;


node traite_genCore_itere(acc_in : int; elt1 : bool; elt2 : int) 
returns (acc_out : int; elt : int); 
let
  elt = if(elt1)
        then elt2
        else acc_in;
  acc_out = acc_in;
tel

node map_red_iter (indice_gen : int ; 
                   InfoGenIndiv  : T_InfoGenIndiv ;
                   InfoGenGlob    : T_InfoGenGlob ;
                   TabEtatCharge : T_EtatCharge^NBC;
                   TabComVal     : bool^NBC) 
        returns (TabComChg  : T_ComChg^NBC);
var bidon : int;
let
   bidon, TabComChg = fillred<<traite_genCore_itere, NBC>>(indice_gen, TabComVal, InfoGenGlob.chg2gen);
tel
