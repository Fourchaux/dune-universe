# This Makefile is used by each of the demos.

# Let's use a fixed shell.
SHELL  := bash

# The following variables can be overridden via the command line or in a
# Makefile that includes this Makefile.

# The variable SWITCH must refer to a version of OCaml that has been
# compiled with support for afl instrumentation.
ifndef SWITCH
  SWITCH := 4.09.1+afl
endif

# The variable EXE represents the path of the executable file that must
# be tested relative to the current directory (the one where [make] is
# run).
ifndef EXE
  EXE := Main.exe
endif

# ----------------------------------------------------------------------------

# Go up to the root of the dune project, and compute the location of the
# build subdirectory that corresponds to the current directory.

BUILD := $(shell \
  up=""; down=""; switch="$(SWITCH)"; \
  while ! [ -f dune-project ] ; do \
    up="../"$$up ; down=/$$(basename $$(pwd))$$down ; \
    cd .. ; \
  done ; \
  path=$$up"_build/"$${switch-default}$$down ; \
  echo $$path \
)

# ----------------------------------------------------------------------------

# [make all] compiles the code in an appropriate opam switch.

.PHONY: all
all:
	@ dune build @check # build src/.merlin, etc.
	@(echo "(lang dune 2.0)" && \
	  echo "(context (opam (switch $(SWITCH))))" \
	 ) > dune-workspace.afl
	@ dune build --workspace dune-workspace.afl --no-print-directory .

# ----------------------------------------------------------------------------

# [make setup] creates the required opam switch. Run it only once.
# This takes several minutes.

# Normally, [make setup] installs the latest *released* version of
# monolith. This is appropriate for normal users. For developers
# of monolith, we check if the current directory seems to be the
# root of a monolith repository, and if so, we pin monolith, so as
# to install the development version of monolith.

.PHONY: setup
setup:
	@ CURRENT=`opam switch show` ; \
	if opam switch list | grep '$(SWITCH) ' >/dev/null ; then \
	  echo "The switch $(SWITCH) already exists." ; \
	  opam switch $(SWITCH) ; \
	else \
	  echo "Creating switch $(SWITCH)..." ; \
	  opam switch create $(SWITCH) ; \
	fi ; \
	eval $$(opam env) ; \
	opam install --yes ocamlfind ; \
	if grep -q fpottier/monolith .git/config 2>/dev/null ; then \
	  echo "Pinning monolith in the switch $(SWITCH)..."; \
	  make pin ; \
	fi ; \
	echo "Installing required packages..." ; \
	opam install --yes monolith ; \
	echo "Switching back to $$CURRENT..." ; \
	opam switch set $$CURRENT >/dev/null ; \

# ----------------------------------------------------------------------------

# [make clean] cleans up.

.PHONY: clean
clean:
	@ dune clean
	@ rm -rf $(INPUT) $(OUTPUT) $(OUTPUT).*
	@ rm -f dune-workspace.afl

# ----------------------------------------------------------------------------

# Settings.

# Directories for input and output files.
INPUT   := input
OUTPUT  := output
CRASHES := \
  $(wildcard $(OUTPUT)/crashes/dummy) \
  $(wildcard $(OUTPUT)/crashes/id*) \
  $(wildcard $(OUTPUT)/*/crashes/id*) \

# This is where dune places the executable file.
BINARY  := $(BUILD)/$(EXE)

# On MacOS, the highest stack size that seems permitted is 65532.
STACK   := ulimit -s 65532

# ----------------------------------------------------------------------------

# [make test] runs afl-fuzz.

# afl-fuzz must be interrupted by Ctrl-C after it has found some crashes
# (or after it has run long enough).

# afl-fuzz refuses to run if the dummy input file $(INPUT)/dummy happens
# to cause a crash right away. This is why we run $(BINARY) once before
# attempting to launch afl-fuzz. If this initial run fails, then we copy
# $(INPUT)/dummy to $(OUTPUT)/crashes, so as to let [make show] and
# [make min] work normally.

.PHONY: test
test: all
	@ if [[ "$$OSTYPE" == "linux-gnu" ]]; then \
	  echo "Disabling the crash reporter, and changing CPU settings" ; \
	  echo "so as to maximize performance." ; \
	  echo "(This uses sudo; you may be asked for your password.)" ; \
	  sudo bash -c \
	    'echo core >/proc/sys/kernel/core_pattern && \
	     cd /sys/devices/system/cpu && \
	     (echo performance | tee cpu*/cpufreq/scaling_governor)' ; \
	fi
	@ rm -rf $(INPUT) $(OUTPUT)
	@ mkdir $(INPUT)
	@ echo "dummy input" > $(INPUT)/dummy
	@ if $(BINARY) $(INPUT)/dummy ; then \
	    $(STACK) && afl-fuzz -i $(INPUT) -o $(OUTPUT) $(BINARY) @@ ; \
	  else \
	    exitcode=$$? ; \
	    mkdir -p $(OUTPUT)/crashes && cp $(INPUT)/dummy $(OUTPUT)/crashes ; \
	    exit $$exitcode ; \
	  fi

# ----------------------------------------------------------------------------

# [make show] displays the problems found by afl-fuzz in the previous run.

.PHONY: show
show:
	@ $(STACK) && \
	  (for f in $(CRASHES) ; do \
	    echo $$f ; \
	    tmp=`mktemp /tmp/crash.XXXX` && \
	    ($(BINARY) $$f > $$tmp 2>&1 || true) >/dev/null 2>&1 ; \
	    cat $$tmp ; \
	    rm $$tmp ; \
	    echo ; \
	  done) | more

# ----------------------------------------------------------------------------

# [make summary] is like [make show], but postprocesses its output so as to
# keep only the last instruction before the crash, and sorts these lines, so
# as to determine the length of the shortest instruction sequence that causes
# a problem.

# If you determine that a crash can be obtained in (say) 4 instructions, then
# typing [make show] and searching for "@04: Failure" will allow you to
# inspect the scenario that caused this crash.

.PHONY: summary
summary:
	@ $(STACK) && \
	  parallel '$(BINARY) {} 2>/dev/null | grep "Failure" | head -n 1' ::: $(CRASHES) \
	  | sort -r

# ----------------------------------------------------------------------------

# [make min] attempts to minimize the problematic inputs found by
# afl-fuzz in the previous run.

.PHONY: min
min:
	@ COPY=`mktemp -d $(OUTPUT).XXXX` && rm -rf $(COPY) && \
	  echo "Saving un-minimized output to $$COPY." && \
	  cp -rf $(OUTPUT) $$COPY
	@ $(STACK) && \
	  parallel 'afl-tmin -i {} -o {} -- $(BINARY) @@' ::: $(CRASHES)

# ----------------------------------------------------------------------------

# [make unload] turns off the MacOS Crash Reporter utility.
# [make load] turns it on again.
# This utility should be OFF for afl-fuzz to work correctly.

SL := /System/Library
PL := com.apple.ReportCrash

.PHONY: unload
unload:
	launchctl unload -w $(SL)/LaunchAgents/$(PL).plist
	sudo launchctl unload -w $(SL)/LaunchDaemons/$(PL).Root.plist

.PHONY: load
load:
	launchctl load -w $(SL)/LaunchAgents/$(PL).plist
	sudo launchctl load -w $(SL)/LaunchDaemons/$(PL).Root.plist
